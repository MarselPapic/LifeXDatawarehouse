<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Detail View</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .section{margin-top:1.2rem}
        .section h2{margin:.2rem 0 .6rem 0;display:flex;align-items:center;gap:.6rem;flex-wrap:wrap}
        .pill{
            display:inline-block;background:#e9f1ff;border:1px solid #cfe0ff;border-radius:999px;
            padding:.15rem .55rem;margin:.12rem .2rem;cursor:pointer;text-decoration:none;color:inherit
        }
        .pill:hover{background:#dbeaff}
        .empty{color:#666}
        .sep{margin:0 .35rem;color:#999}
        .section h2 .count{color:#6b7280;font-size:.9rem;font-weight:400}
        .add-link{
            display:inline-flex;align-items:center;justify-content:center;
            width:1.8rem;height:1.8rem;border-radius:999px;border:1px solid #2c64b5;
            color:#2c64b5;text-decoration:none;font-weight:600;font-size:1.2rem;line-height:1;
            transition:background .2s ease,color .2s ease;
        }
        .section h2 .add-link{margin-left:auto}
        .add-link:focus,.add-link:hover{background:#2c64b5;color:#fff;outline:2px solid transparent;outline-offset:2px;box-shadow:0 0 0 2px rgba(44,100,181,.35)}
        .status-badge{display:inline-flex;align-items:center;gap:.25rem;padding:.12rem .55rem;border-radius:999px;font-size:.82rem;font-weight:600;border:1px solid transparent;}
        .status-badge--planned{background:#eef2ff;border-color:#c7d2fe;color:#3730a3;}
        .status-badge--active{background:#ecfdf5;border-color:#a7f3d0;color:#047857;}
        .status-badge--maintenance{background:#fff7ed;border-color:#fed7aa;color:#c2410c;}
        .status-badge--retired{background:#f5f5f5;border-color:#d4d4d4;color:#52525b;}
        .status-badge--offered{background:#f0f9ff;border-color:#bae6fd;color:#0369a1;}
        .status-badge--installed{background:#ecfdf5;border-color:#bbf7d0;color:#047857;}
        .status-badge--rejected{background:#fef2f2;border-color:#fecaca;color:#b91c1c;}
        .nav-buttons{display:flex;gap:.75rem;margin-bottom:1.5rem;flex-wrap:wrap;align-items:center}
        .nav-buttons a{
            display:inline-flex;align-items:center;gap:.4rem;padding:.48rem 1.05rem;border-radius:.55rem;
            text-decoration:none;font-weight:600;font-size:.95rem;border:none;color:#fff;background:#0067c2;
            transition:background .2s ease,color .2s ease,box-shadow .2s ease;
            box-shadow:0 2px 4px rgba(15,23,42,.12);
        }
        .nav-buttons a:focus,.nav-buttons a:hover{background:#0054a6;color:#fff;outline:2px solid transparent;outline-offset:2px;box-shadow:0 0 0 2px rgba(0,103,194,.2)}
        .software-overview{display:grid;gap:1rem;margin-top:.5rem}
        .software-overview__item{border:1px solid #e5e7eb;border-radius:.75rem;padding:1rem;background:#fff;box-shadow:0 1px 2px rgba(15,23,42,.04)}
        .software-overview__header{display:flex;align-items:center;gap:.65rem;flex-wrap:wrap}
        .software-overview__name{font-weight:600;font-size:1.05rem;color:#111827;text-decoration:none}
        .software-overview__name:hover,.software-overview__name:focus{text-decoration:underline}
        .software-overview__version{color:#4b5563;font-size:.9rem}
        .software-overview__status-text{font-weight:600;color:#374151}
        .software-overview__meta{margin:.75rem 0 0 0;padding:0;list-style:none;display:flex;flex-wrap:wrap;gap:.5rem 1.5rem;font-size:.9rem;color:#4b5563}
        .software-overview__meta li{display:flex;align-items:center;gap:.35rem}
        .software-overview__meta-label{font-weight:600;color:#1f2937;position:relative}
        .software-overview__meta-label::after{content:':';margin-left:.1rem;color:#6b7280}
        .software-overview__meta a{color:#1d4ed8;text-decoration:none}
        .software-overview__meta a:hover,.software-overview__meta a:focus{text-decoration:underline}
        .software-overview__notes{margin:.75rem 0 0 0;color:#4b5563;font-size:.9rem;line-height:1.4}
    </style>
</head>
<body>

<a href="#main" class="skip-link">Skip to content</a>

<header>
    <img src="/img/LifeXDatawarehouseLogo.png" alt="">
    <nav aria-label="Main navigation">
        <a href="/index.html">Dashboard</a>
        <a href="/create.html">Create Data</a>
        <a href="/reports.html">Reports</a>
    </nav>
</header>

<main id="main" style="max-width:1000px;margin:2rem auto">
    <div class="nav-buttons">
        <a id="back-history" href="index.html">← Back</a>
        <a id="back-dashboard" href="/index.html">Dashboard</a>
    </div>
    <div id="detail-layout">
        <div id="view" class="card" role="region" aria-live="polite" aria-busy="true">loading …</div>
        <div id="site-software-overview-card" class="card site-software-card" role="region" aria-live="polite" aria-label="Software overview" hidden>
            <div class="site-software-card__body"></div>
        </div>
    </div>

    <!-- Parent relationships section -->
    <div id="parents"></div>

    <!-- Child entity listings -->
    <div id="children"></div>
</main>

<script src="/js/entity-type-map.js"></script>
<script src="/js/form-config.js"></script>
<script>
    /* -------------------- Helpers -------------------- */
    const PKS = {
        Account: 'AccountID',
        Project: 'ProjectID',
        Site: 'SiteID',
        Server: 'ServerID',
        Clients: 'ClientID',
        Radio: 'RadioID',
        AudioDevice: 'AudioDeviceID',
        PhoneIntegration: 'PhoneIntegrationID',
        Country: 'CountryCode',
        City: 'CityID',
        Address: 'AddressID',
        DeploymentVariant: 'VariantID',
        Software: 'SoftwareID',
        UpgradePlan: 'UpgradePlanID',
        ServiceContract: 'ContractID'
    };

    const LIFECYCLE_STATUS_DISPLAY = {
        PLANNED: { label: 'Planned', tone: 'planned' },
        ACTIVE: { label: 'Active', tone: 'active' },
        MAINTENANCE: { label: 'Maintenance', tone: 'maintenance' },
        RETIRED: { label: 'Retired', tone: 'retired' }
    };

    const INSTALL_STATUS_DISPLAY = {
        OFFERED: { label: 'Offered', tone: 'offered' },
        INSTALLED: { label: 'Installed', tone: 'installed' },
        REJECTED: { label: 'Rejected', tone: 'rejected' }
    };

    const ALLOWED_AUDIO_DEVICE_TYPES = new Set(['HEADSET','SPEAKER','MIC']);

    function normalizeLifecycleStatus(value){
        return (value ?? '').toString().trim().toUpperCase();
    }

    function renderLifecycleStatusBadge(value){
        const normalized = normalizeLifecycleStatus(value);
        const entry = LIFECYCLE_STATUS_DISPLAY[normalized];
        if(!entry){
            const raw = value === null || value === undefined ? '' : String(value);
            return escapeHtml(raw);
        }
        return `<span class="status-badge status-badge--${entry.tone}">${escapeHtml(entry.label)}</span>`;
    }

    function normalizeInstallStatus(value){
        return (value ?? '').toString().trim().toUpperCase();
    }

    function renderInstallStatusBadge(value, displayLabel){
        const normalized = normalizeInstallStatus(value);
        const entry = INSTALL_STATUS_DISPLAY[normalized];
        if(!entry){
            const raw = displayLabel ?? value;
            return raw === undefined || raw === null ? '' : escapeHtml(String(raw));
        }
        const label = displayLabel ?? entry.label;
        return `<span class="status-badge status-badge--${entry.tone}">${escapeHtml(label)}</span>`;
    }



    let currentRow = null;
    let currentTable = null;
    let currentId = null;
    let currentRawType = null;
    let isEditing = false;
    let currentSiteSoftwareAssignments = [];
    let softwareOptionCache = null;
    let softwareOptionLoadError = null;

    const detailBox = document.getElementById('view');
    const detailLayoutEl = document.getElementById('detail-layout');
    const siteSoftwareOverviewCard = document.getElementById('site-software-overview-card');
    const siteSoftwareOverviewBody = siteSoftwareOverviewCard?.querySelector('.site-software-card__body') || null;
    const parentsBox = document.getElementById('parents');
    const childrenBox = document.getElementById('children');

    let detailTitleEl;
    let detailTypeEl;
    let detailBodyEl;
    let detailStatusEl;
    let editButtonEl;
    const defaultDocumentTitle = document.title || 'Detail View';
    const defaultDashboardHref = 'index.html';

    document.addEventListener('DOMContentLoaded', () => {
        const historyButton = document.getElementById('back-history');
        if(!historyButton) return;

        const dashboardButton = document.getElementById('back-dashboard');
        const fallbackHref = dashboardButton?.getAttribute('href') || defaultDashboardHref;
        historyButton.setAttribute('href', fallbackHref);

        const referrer = document.referrer;
        let shouldUseHistory = false;

        if(referrer){
            try{
                const refUrl = new URL(referrer, window.location.href);
                const pathMatches = refUrl.pathname.endsWith('/details.html');
                const searchParams = refUrl.searchParams;
                if(pathMatches && searchParams.has('type') && searchParams.has('id')){
                    shouldUseHistory = true;
                    historyButton.setAttribute('href', refUrl.href);
                }
            }catch(err){
                shouldUseHistory = false;
            }
        }

        if(shouldUseHistory){
            historyButton.addEventListener('click', event => {
                if(!shouldUseHistory){
                    historyButton.setAttribute('href', fallbackHref);
                    return;
                }
                if(window.history.length <= 1){
                    historyButton.setAttribute('href', fallbackHref);
                    shouldUseHistory = false;
                    return;
                }

                event.preventDefault();

                let fallbackTimer;
                const cleanup = () => {
                    if(fallbackTimer !== undefined){
                        window.clearTimeout(fallbackTimer);
                    }
                    window.removeEventListener('popstate', cleanup);
                };

                fallbackTimer = window.setTimeout(() => {
                    cleanup();
                    window.location.href = fallbackHref;
                }, 600);

                window.addEventListener('popstate', cleanup);

                window.history.back();
            });
        }
    });

    function escapeHtml(value){
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
        };
        return (value ?? '').toString().replace(/[&<>"']/g, c => map[c] ?? c);
    }
    function shortId(value){
        const str = (value ?? '').toString().trim();
        if(!str) return '';
        const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
        if(uuidPattern.test(str)){
            const idx = str.lastIndexOf('-');
            if(idx !== -1 && idx < str.length - 1){
                const lastSegment = str.slice(idx + 1).replace(/^0+/, '');
                const compact = lastSegment || '0';
                return `#${compact}`;
            }
        }
        return str.startsWith('#') ? str : `#${str}`;
    }
    function formatIdChip(id){
        const full = (id ?? '').toString().trim();
        if(!full) return '';
        const display = shortId(full);
        return `<span class="id-chip" title="${escapeHtml(full)}">${escapeHtml(display)}</span>`;
    }
    const entityTypeRegistry = window.EntityTypeRegistry || null;
    function tableForType(t){
        if(entityTypeRegistry && typeof entityTypeRegistry.canonicalTableForType === 'function'){
            return entityTypeRegistry.canonicalTableForType(t);
        }
        const s=(t||'').toLowerCase();
        switch(s){
            case 'account': return 'Account';
            case 'project': return 'Project';
            case 'site': return 'Site';
            case 'server': return 'Server';
            case 'client': return 'Clients'; // changed from WorkingPosition
            case 'radio': return 'Radio';
            case 'audio': return 'AudioDevice';
            case 'phone': return 'PhoneIntegration';
            case 'country': return 'Country';
            case 'city': return 'City';
            case 'address': return 'Address';
            case 'deploymentvariant': return 'DeploymentVariant';
            case 'software': return 'Software';
            case 'upgradeplan': return 'UpgradePlan';
            case 'servicecontract': return 'ServiceContract';
            default: return t;
        }
    }
    function configKeyForTable(table){
        if(entityTypeRegistry && typeof entityTypeRegistry.canonicalConfigKeyForTable === 'function'){
            return entityTypeRegistry.canonicalConfigKeyForTable(table);
        }
        const normalized = tableForType(table);
        if(!normalized) return null;
        if(normalized === 'Clients') return 'WorkingPosition';
        return normalized;
    }
    function val(row, ...keys){
        if(!row || typeof row !== 'object') return undefined;
        for(const k of keys){
            if(k === undefined || k === null) continue;
            const keyStr = String(k);
            if(keyStr && Object.prototype.hasOwnProperty.call(row, keyStr) && row[keyStr] !== undefined){
                return row[keyStr];
            }
            const upper = keyStr.toUpperCase();
            const lower = keyStr.toLowerCase();
            for(const kk in row){
                if(kk === keyStr || kk === upper || kk === lower || kk.toLowerCase() === lower){
                    const value = row[kk];
                    if(value !== undefined) return value;
                }
            }
        }
        return undefined;
    }
    function formatDateLabel(value){
        if (value === null || value === undefined) return '';
        const str = ('' + value).trim();
        if (!str) return '';
        const ts = Date.parse(str);
        if (!Number.isNaN(ts)) {
            return new Date(ts).toLocaleDateString('en-US', { year: 'numeric', month: '2-digit', day: '2-digit' });
        }
        return str;
    }
    function formatDateRange(start, end){
        const from = formatDateLabel(start);
        const to = formatDateLabel(end);
        if (from && to) return `${from} → ${to}`;
        return from || to || '';
    }
    const formConfig = window.FormConfig || {getFields:()=>[], asyncSources:{}};
    let detailAsyncSelectConfigs = {};
    let detailFormRef = null;

    const escapeAttr = value => String(value ?? '')
        .replace(/&/g,'&amp;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;');

    const renderAttributes = attrs => Object.entries(attrs)
        .map(([key,value])=>{
            if(value===undefined||value===null||value===false) return '';
            if(value===true) return ` ${key}`;
            return ` ${key}="${escapeAttr(value)}"`;
        }).join('');

    const toChoices = choices => {
        if(!Array.isArray(choices)) return [];
        return choices.map(choice => {
            if(choice && typeof choice === 'object'){
                return {value: choice.value, label: choice.label ?? choice.value};
            }
            return {value: choice, label: choice};
        });
    };

    const renderInputField = (id,label,opts={}) => {
        const config = {...opts};
        if(config.required === undefined) config.required = true;
        const attributes = {
            id,
            name: config.name || id,
            type: config.type || 'text',
            placeholder: config.placeholder,
            pattern: config.pattern,
            maxlength: config.maxlength,
            minlength: config.minlength,
            min: config.min,
            max: config.max,
            step: config.step,
            autocomplete: config.autocomplete,
            inputmode: config.inputmode,
            value: config.value,
            'data-value-type': config.valueType || undefined,
        };
        if(config.required === false) delete attributes.required; else attributes.required = true;
        if(config.dataset){
            Object.entries(config.dataset).forEach(([key,value])=>{
                if(value!==undefined && value!==null){
                    attributes[`data-${key}`]=value;
                }
            });
        }
        if(config.className) attributes.class=config.className;
        const attrs = renderAttributes(attributes);
        return `<label for="${id}" class="detail-field"><span class="detail-field-label">${escapeHtml(label)}</span><input class="detail-input"${attrs}></label>`;
    };

    const renderSelectField = (id,label,choices,opts={}) => {
        const config = {...opts};
        if(config.required === undefined) config.required = true;
        const placeholder = config.placeholder ?? 'Please select';
        const selectedValue = config.value ?? '';
        const values = toChoices(choices);
        const selectAttrs = renderAttributes({id, name: config.name || id, required: config.required!==false, 'data-value-type': config.valueType || undefined});
        const optionsHtml = values.map(option=>`<option value="${escapeAttr(option.value)}"${String(option.value)===String(selectedValue)?' selected':''}>${escapeAttr(option.label)}</option>`).join('');
        return `<label for="${id}" class="detail-field"><span class="detail-field-label">${escapeHtml(label)}</span><select class="detail-input"${selectAttrs}><option value="">${escapeAttr(placeholder)}</option>${optionsHtml}</select></label>`;
    };

    function renderDetailAsyncSelect(id,label,sourceKey,options={}){
        const {required=true, allowManual=true, placeholder='Please select', dependsOn=null, emptyText='No entries available', filter=null, name=null, value=null} = options;
        detailAsyncSelectConfigs[id]={sourceKey, required, allowManual, placeholder, dependsOn, emptyText, filter, name, initialValue:value};
        const manualToggle = allowManual ? `<button type="button" class="toggle-manual" data-field="${id}">Enter manual value</button>` : '';
        const manualValue = value ?? '';
        const manualInput = allowManual ? `<input type="text" id="${id}-manual" class="hidden" placeholder="Enter UUID" value="${escapeAttr(manualValue)}" ${required?'required':''}>` : '';
        const hiddenName = name ? ` name="${escapeAttr(name)}"` : '';
        const hiddenValue = value!=null ? ` value="${escapeAttr(value)}"` : '';
        const valueTypeAttr = ` data-value-type="${escapeAttr(options.valueType || 'text')}"`;
        return `<label class="detail-field"><span class="detail-field-label">${escapeHtml(label)}</span>
            <div class="async-select" data-field="${id}" data-source="${sourceKey}" data-required="${required}"${dependsOn?` data-depends-on="${dependsOn}"`:''}>
                <select id="${id}-select" class="detail-input" ${required?'required':''}>
                    <option value="">${escapeAttr(placeholder)}</option>
                </select>
                ${manualInput}
                <input type="hidden" id="${id}"${hiddenName}${hiddenValue}${valueTypeAttr}>
                ${manualToggle}
            </div>
        </label>`;
    }

    function renderFieldForDetails(field, overrides={}){
        if(!field) return '';
        const config={...field,...overrides};
        const component=(config.component||'input').toLowerCase();
        if(component==='softwarelist'){
            return '';
        }
        if(component==='select'){
            if(!config.valueType) config.valueType='text';
        }else if(component==='asyncselect'){
            if(!config.valueType) config.valueType='text';
        }else{
            const hint=(config.inputType||config.type||'').toLowerCase();
            if(!config.valueType){
                if(hint==='number') config.valueType='number';
                else if(hint==='date') config.valueType='date';
                else config.valueType='text';
            }
        }
        if(component==='select'){
            return renderSelectField(config.id, config.label, config.options||[], config);
        }
        if(component==='asyncselect'){
            return renderDetailAsyncSelect(config.id, config.label, config.source, {
                required: config.required!==false,
                allowManual: config.allowManual!==false,
                placeholder: config.placeholder,
                dependsOn: config.dependsOn||null,
                emptyText: config.emptyText,
                name: config.name,
                value: config.value,
                valueType: config.valueType
            });
        }
        const inputConfig={
            required: config.required!==false,
            type: config.inputType||config.type||'text',
            placeholder: config.placeholder,
            pattern: config.pattern,
            maxlength: config.maxlength,
            minlength: config.minlength,
            min: config.min,
            max: config.max,
            step: config.step,
            autocomplete: config.autocomplete,
            inputmode: config.inputmode,
            dataset: config.dataset,
            name: config.name,
            value: config.value,
            valueType: config.valueType
        };
        return renderInputField(config.id, config.label, inputConfig);
    }

    function detailPopulateOptions(select,entries,options={}){
        const {placeholder='Please select', allowEmpty=false}=options;
        const currentValue = select.value;
        select.innerHTML='';
        if(placeholder!==null){
            const opt=document.createElement('option');
            opt.value='';
            opt.textContent=placeholder;
            select.appendChild(opt);
        }
        entries.filter(Boolean).forEach(entry=>{
            const opt=document.createElement('option');
            opt.value=entry.value;
            opt.textContent=entry.label || entry.value;
            select.appendChild(opt);
        });
        if(entries.length>0 && entries.some(e=>e && e.value===currentValue)){
            select.value=currentValue;
        }else if(allowEmpty){
            select.value='';
        }else{
            select.value='';
        }
    }

    function detailUpdateValueProxy(id,value){
        const hidden=document.getElementById(id);
        if(!hidden) return;
        const newValue=value??'';
        if(hidden.value===newValue) return;
        hidden.value=newValue;
        hidden.dispatchEvent(new CustomEvent('value-changed',{bubbles:true,detail:{value:newValue}}));
    }

    function detailGetAsyncContainer(id){
        const form = detailFormRef;
        if(!form) return null;
        return form.querySelector(`.async-select[data-field="${id}"]`);
    }

    function detailSetManualMode(id,mode){
        const container=detailGetAsyncContainer(id);
        if(!container) return;
        const select=container.querySelector('select');
        const manual=container.querySelector(`#${id}-manual`);
        const toggle=container.querySelector('.toggle-manual');
        const required=container.dataset.required==='true';
        if(!manual){
            container.dataset.mode='select';
            select?.classList.remove('hidden');
            if(select && required) select.setAttribute('required','');
            return;
        }
        if(mode==='manual'){
            select?.classList.add('hidden');
            if(select) select.removeAttribute('required');
            select?.setAttribute('aria-hidden','true');
            if(select) select.disabled=true;
            manual.classList.remove('hidden');
            if(required) manual.setAttribute('required',''); else manual.removeAttribute('required');
            if(toggle) toggle.textContent='Choose from list';
            container.dataset.mode='manual';
            detailUpdateValueProxy(id,manual.value?.trim()||'');
        }else{
            manual.classList.add('hidden');
            manual.removeAttribute('required');
            select?.classList.remove('hidden');
            if(select){
                select.removeAttribute('aria-hidden');
                if(required) select.setAttribute('required','');
                select.disabled = select.options.length===0;
            }
            if(toggle) toggle.textContent='Enter manual value';
            container.dataset.mode='select';
            detailUpdateValueProxy(id,select?select.value:'');
        }
    }

    async function detailLoadOptionsForField(id){
        const config=detailAsyncSelectConfigs[id];
        if(!config) return;
        const container=detailGetAsyncContainer(id);
        if(!container) return;
        const select=container.querySelector('select');
        const manual=container.querySelector(`#${id}-manual`);
        if(!select) return;
        const dependencyId=config.dependsOn;
        const dependencyValue=dependencyId?document.getElementById(dependencyId)?.value?.trim():undefined;
        if(dependencyId && !dependencyValue){
            select.innerHTML='';
            detailPopulateOptions(select,[],{placeholder:'Please select the dependent value first',allowEmpty:true});
            select.disabled=true;
            if(manual){
                manual.value='';
                if(container.dataset.mode!=='manual') detailUpdateValueProxy(id,'');
            }
            return;
        }

        const source=formConfig.asyncSources[config.sourceKey];
        if(!source){
            select.innerHTML='';
            select.disabled=true;
            if(manual){
                manual.value='';
                if(container.dataset.mode!=='manual') detailUpdateValueProxy(id,'');
                if(config.allowManual!==false) detailSetManualMode(id,'manual');
            }
            return;
        }

        select.disabled=true;
        select.innerHTML=`<option value="">Loading data…</option>`;
        try{
            const url=typeof source.url==='function'?source.url(dependencyValue):source.url;
            const data=await fetchJson(url);
            let entries=(Array.isArray(data)?data:[]).map(source.map).filter(Boolean);
            if(typeof config.filter==='function'){
                entries=entries.filter(entry=>config.filter(entry, dependencyValue));
            }
            const placeholderText = entries.length===0 ? (config.emptyText||config.placeholder) : config.placeholder;
            detailPopulateOptions(select,entries,{placeholder:placeholderText,allowEmpty:!config.required});
            select.disabled=entries.length===0;
            const initialValue=config.initialValue;
            if(container.dataset.mode!=='manual'){
                if(initialValue!=null && entries.some(entry=>entry && String(entry.value)===String(initialValue))){
                    select.value=initialValue;
                    detailUpdateValueProxy(id,initialValue);
                }else{
                    select.value='';
                    detailUpdateValueProxy(id,'');
                }
            }
            if(entries.length===0 && config.allowManual!==false){
                if(manual){
                    manual.value=initialValue??'';
                    detailSetManualMode(id,'manual');
                }
            }else if(container.dataset.mode!=='manual'){
                detailSetManualMode(id,'select');
            }
            config.initialValue=undefined;
        }catch(err){
            console.error(err);
            detailPopulateOptions(select,[],{placeholder:'Error loading data'});
            select.disabled=true;
            if(config.allowManual!==false){
                detailSetManualMode(id,'manual');
            }
        }
    }

    function detailInitializeAsyncSelects(form){
        detailFormRef = form;
        Object.keys(detailAsyncSelectConfigs).forEach(id=>{
            const container=form.querySelector(`.async-select[data-field="${id}"]`);
            if(!container) return;
            const select=container.querySelector('select');
            const manual=container.querySelector(`#${id}-manual`);
            const toggle=container.querySelector('.toggle-manual');
            const hidden=form.querySelector(`#${id}`);
            const cfg=detailAsyncSelectConfigs[id]||{};
            if(hidden) hidden.value=cfg.initialValue??'';
            if(manual && cfg.initialValue!=null){
                manual.value=cfg.initialValue;
            }
            container.dataset.mode='select';
            if(select){
                select.addEventListener('change',()=>{
                    if(container.dataset.mode!=='manual'){
                        detailUpdateValueProxy(id,select.value);
                    }
                });
            }
            if(manual){
                manual.addEventListener('input',()=>{
                    if(container.dataset.mode==='manual'){
                        detailUpdateValueProxy(id,manual.value.trim());
                    }
                });
            }
            if(toggle){
                toggle.addEventListener('click',()=>{
                    detailSetManualMode(id,container.dataset.mode==='manual'?'select':'manual');
                });
            }
            if(manual && container.dataset.required==='true'){
                manual.removeAttribute('required');
            }
            detailSetManualMode(id,'select');
        });

        Object.entries(detailAsyncSelectConfigs).forEach(([id,config])=>{
            if(config.dependsOn){
                const dep=document.getElementById(config.dependsOn);
                if(dep){
                    dep.addEventListener('value-changed',()=>detailLoadOptionsForField(id));
                }
            }
            detailLoadOptionsForField(id);
        });
    }

    function detailApplyInputEnhancements(form){
        form.querySelectorAll('input[data-uppercase="true"]').forEach(input=>{
            input.addEventListener('input',()=>{
                const start=input.selectionStart;
                const end=input.selectionEnd;
                const upper=input.value.toUpperCase();
                if(input.value!==upper){
                    input.value=upper;
                    if(start!==null && end!==null){
                        input.setSelectionRange(start,end);
                    }
                }
            });
        });
    }

    function detailApplyValidationMessages(form){
        const inputs=form ? Array.from(form.querySelectorAll('input')) : [];
        inputs.forEach(input=>{
            if(!input) return;
            if(input.type==='hidden') return;

            const patternAttr=input.getAttribute('pattern');
            let matchesCountryPattern=false;
            if(patternAttr){
                try{
                    const tester=new RegExp(patternAttr);
                    matchesCountryPattern=tester.test('AA') && !tester.test('AAA');
                }catch(_){
                    matchesCountryPattern=false;
                }
            }

            const shouldHandle=(()=>{
                if(input.required) return true;
                if(['email','tel'].includes(input.type)) return true;
                if(['email','phone','countryCode'].includes(input.id)) return true;
                if(matchesCountryPattern) return true;
                return false;
            })();
            if(!shouldHandle) return;

            const getMessage=()=>{
                const {validity}=input;
                if(!validity) return '';
                if(validity.valueMissing){
                    return 'Please fill out this field.';
                }
                if((validity.typeMismatch||validity.patternMismatch)&&(input.type==='email'||input.id==='email')){
                    return 'Please enter a valid email address.';
                }
                if((validity.typeMismatch||validity.patternMismatch)&&(input.type==='tel'||input.id==='phone')){
                    return 'Please enter a valid phone number (digits, spaces, and common separators are allowed).';
                }
                if(validity.patternMismatch&&(input.id==='countryCode'||matchesCountryPattern)){
                    return 'Please enter a two-letter country code.';
                }
                return '';
            };

            input.addEventListener('invalid',()=>{
                input.setCustomValidity(getMessage());
            });
            input.addEventListener('input',()=>{
                input.setCustomValidity('');
            });
        });
    }

    function labelFor(type, row){
        switch((type||'').toLowerCase()){
            case 'account': return `${val(row,'AccountName') ?? 'Account'}`;
            case 'project': return `${val(row,'ProjectName') ?? 'Project'}`;
            case 'site':    return `${val(row,'SiteName') ?? 'Site'}`;
            case 'server':  return `${val(row,'ServerName') ?? 'Server'}`;
            case 'client':
            case 'clients': return `${val(row,'ClientName') ?? 'Client'}`;
            case 'radio':   return `${val(row,'RadioBrand') ?? 'Radio'}`;
            case 'audio':   return `${val(row,'AudioDeviceBrand') ?? 'AudioDevice'}`;
            case 'phone':   return `${val(row,'PhoneBrand') ?? 'Phone'}`;
            case 'country': return `${val(row,'CountryName') ?? val(row,'CountryCode') ?? 'Country'}`;
            case 'city':    return `${val(row,'CityName') ?? 'City'}`;
            case 'address': return `${val(row,'Street') ?? 'Address'}`;
            case 'deploymentvariant': return `${val(row,'VariantName') ?? 'DeploymentVariant'}`;
            case 'software': return `${val(row,'Name') ?? 'Software'}`;
            case 'upgradeplan': return `${val(row,'UpgradePlanID') ?? 'UpgradePlan'}`;
            case 'servicecontract': return `${val(row,'ContractNumber') ?? 'ServiceContract'}`;
            default:        return '';
        }
    }
    async function fetchJson(url){
        const res = await fetch(url);
        if(!res.ok) return null;
        return res.json();
    }
    function pillLink(href, label, id, description){
        const a = document.createElement('a');
        a.className = 'pill';
        a.href = href;
        const labelHtml = label ? escapeHtml(label) : '';
        const chipHtml = formatIdChip(id);
        const descHtml = (description ?? '').toString().trim();
        const safeDesc = descHtml ? escapeHtml(descHtml) : '';
        let html = '';
        if(labelHtml) html += labelHtml;
        if(chipHtml){
            html += (html ? ' ' : '') + chipHtml;
        }
        if(safeDesc){
            html += (html ? ' – ' : '') + safeDesc;
        }
        if(!html){
            html = escapeHtml(href);
        }
        a.innerHTML = html;
        return a;
    }
    function buildCreateHref(meta){
        if(!meta || !meta.entity) return null;
        const params = new URLSearchParams();
        params.set('entity', meta.entity);
        const entries = meta.params && typeof meta.params === 'object' ? Object.entries(meta.params) : [];
        entries.forEach(([key,value])=>{
            if(value!==undefined && value!==null && value!==''){
                params.set(key, value);
            }
        });
        const query = params.toString();
        return `create.html${query ? `?${query}` : ''}`;
    }
    function describeCreateMeta(meta){
        if(!meta) return '';
        const label = meta.label || meta.entity || '';
        const contextParts = [];
        const ctx = meta.params || {};
        if(ctx.accountId) contextParts.push(`Account ${shortId(ctx.accountId).replace(/^##/, '#')}`);
        if(ctx.projectId) contextParts.push(`Project ${shortId(ctx.projectId).replace(/^##/, '#')}`);
        if(ctx.siteId) contextParts.push(`Site ${shortId(ctx.siteId).replace(/^##/, '#')}`);
        if(ctx.clientId) contextParts.push(`Client ${shortId(ctx.clientId).replace(/^##/, '#')}`);
        if(ctx.cityId) contextParts.push(`City ${shortId(ctx.cityId).replace(/^##/, '#')}`);
        if(ctx.softwareId){
            const fallbackId = shortId(ctx.softwareId).replace(/^##/, '#');
            const rawLabel = (meta.softwareLabel ?? ctx.softwareLabel ?? '').toString().trim();
            const cleanedLabel = rawLabel.replace(/^Software\s+/i, '').trim();
            const baseLabel = cleanedLabel || fallbackId.replace(/^Software\s+/i, '').trim();
            const finalLabel = baseLabel ? `Software ${baseLabel}` : 'Software';
            contextParts.push(finalLabel.trim());
        }
        if(contextParts.length){
            return `Create new ${label} for ${contextParts.join(' and ')}`;
        }
        return `Create new ${label}`;
    }
    function addSection(container, title, items, toLink, createMeta){
        const list = Array.isArray(items) ? items : [];
        const sec = document.createElement('div');
        sec.className = 'section';
        const heading = document.createElement('h2');
        heading.innerHTML = `${escapeHtml(title)} <span class="count">(${list.length})</span>`;
        if(createMeta){
            const href = buildCreateHref(createMeta);
            if(href){
                const addLink = document.createElement('a');
                addLink.className = 'add-link';
                addLink.href = href;
                const aria = describeCreateMeta(createMeta);
                addLink.setAttribute('aria-label', aria);
                addLink.title = aria;
                addLink.textContent = '+';
                heading.appendChild(addLink);
            }
        }
        sec.appendChild(heading);
        if(!list.length){
            const empty = document.createElement('div');
            empty.className = 'empty';
            empty.textContent = '(no entries)';
            sec.appendChild(empty);
            container.appendChild(sec);
            return;
        }
        const wrap = document.createElement('div');
        list.forEach(it => wrap.appendChild(toLink(it)));
        sec.appendChild(wrap);
        container.appendChild(sec);
    }

    const SOFTWARE_OVERVIEW_ENDPOINT_BUILDERS = [
        (ctx = {}) => ctx.siteId ? `/sites/${encodeURIComponent(ctx.siteId)}/software` : null,
        (ctx = {}) => ctx.siteId ? `/sites/${encodeURIComponent(ctx.siteId)}/software/overview` : null,
        (ctx = {}) => ctx.siteId ? `/api/sites/${encodeURIComponent(ctx.siteId)}/software` : null,
        (ctx = {}) => ctx.siteId ? `/api/sites/${encodeURIComponent(ctx.siteId)}/software/overview` : null,
        (ctx = {}) => {
            const params = new URLSearchParams();
            if(ctx.siteId) params.set('siteId', ctx.siteId);
            if(ctx.softwareId) params.set('softwareId', ctx.softwareId);
            const query = params.toString();
            return `/api/software-overview${query ? `?${query}` : ''}`;
        },
        (ctx = {}) => ctx.softwareId ? `/software/${encodeURIComponent(ctx.softwareId)}/deployments` : null,
        (ctx = {}) => ctx.softwareId ? `/software/${encodeURIComponent(ctx.softwareId)}/sites` : null,
        (ctx = {}) => ctx.softwareId ? `/api/software/${encodeURIComponent(ctx.softwareId)}/deployments` : null,
        (ctx = {}) => ctx.softwareId ? `/api/software/${encodeURIComponent(ctx.softwareId)}/sites` : null,
    ];

    function mapSoftwareOverviewItems(items){
        if(!Array.isArray(items)) return [];
        return items.map(item => {
            if(!item || typeof item !== 'object') return null;
            if(item.__normalizedSoftwareOverview) return item;
            const normalized = normalizeSoftwareOverviewEntry(item);
            if(!normalized) return null;
            return {
                ...item,
                installedSoftwareId: normalized.installedSoftwareId,
                softwareId: normalized.softwareId,
                siteId: normalized.siteId,
                softwareDisplayName: normalized.softwareDisplayName,
                siteDisplayName: normalized.siteDisplayName,
                rawSoftwareName: normalized.rawSoftwareName,
                rawSiteName: normalized.rawSiteName,
                release: normalized.release,
                revision: normalized.revision,
                status: normalized.status,
                fallbackStatus: normalized.fallbackStatus,
                statusLabel: normalized.statusLabel,
                statusSince: normalized.statusSince,
                installedAt: normalized.installedAt,
                offeredAt: normalized.offeredAt,
                plannedStart: normalized.plannedStart,
                plannedEnd: normalized.plannedEnd,
                createdAt: normalized.createdAt,
                updatedAt: normalized.updatedAt,
                supportStart: normalized.supportStart,
                supportEnd: normalized.supportEnd,
                supportPhase: normalized.supportPhase,
                lifecycleStatus: normalized.lifecycleStatus,
                licenseModel: normalized.licenseModel,
                thirdParty: normalized.thirdParty,
                vendorName: normalized.vendorName,
                notes: normalized.notes,
                projectId: normalized.projectId,
                projectName: normalized.projectName,
                accountId: normalized.accountId,
                accountName: normalized.accountName,
                fireZone: normalized.fireZone,
                tenantCount: normalized.tenantCount,
                __normalizedSoftwareOverview: true
            };
        }).filter(Boolean);
    }

    async function fetchSoftwareOverview(context = {}){
        const seen = new Set();
        for(const builder of SOFTWARE_OVERVIEW_ENDPOINT_BUILDERS){
            let url = null;
            try {
                url = builder(context);
            } catch {
                url = null;
            }
            if(!url || seen.has(url)) continue;
            seen.add(url);
            try {
                const data = await fetchJson(url);
                if(Array.isArray(data)){
                    return mapSoftwareOverviewItems(data);
                }
            } catch {
                // ignore failed endpoint attempts
            }
        }
        return [];
    }

    function normalizeSoftwareOverviewEntry(item){
        if(!item || typeof item !== 'object') return null;

        const installedSoftwareId = val(item,'InstalledSoftwareID','installedSoftwareID','installedSoftwareId','installationId');
        const softwareId = val(item,'SoftwareID','softwareID','softwareId','SoftwareId','Id','ID');
        const siteId = val(item,'SiteID','siteID','siteId','SiteId');

        const rawSoftwareName = (val(item,'SoftwareName','softwareName','Software','software','SoftwareLabel','softwareLabel','Name','name','Label','label','Title','title') ?? '').toString().trim();
        const rawSiteName = (val(item,'SiteName','siteName','Site','site','SiteLabel','siteLabel','Location','location') ?? '').toString().trim();

        const softwareDisplayName = rawSoftwareName || (softwareId ? `Software ${shortId(softwareId).replace(/^##/, '#')}` : 'Software');
        const siteDisplayName = rawSiteName || (siteId ? `Site ${shortId(siteId).replace(/^##/, '#')}` : 'Site');

        const primaryStatus = val(item,'Status','status','State','state','InstallStatus','installStatus');
        const statusLabel = val(item,'StatusLabel','statusLabel','StatusText','statusText');
        const lifecycleStatus = val(item,'LifecycleStatus','lifecycleStatus');
        const supportPhase = val(item,'SupportPhase','supportPhase');
        const phase = val(item,'Phase','phase');
        const fallbackStatus = primaryStatus ?? lifecycleStatus ?? supportPhase ?? phase ?? null;

        return {
            installedSoftwareId,
            softwareId,
            siteId,
            softwareDisplayName,
            siteDisplayName,
            rawSoftwareName,
            rawSiteName,
            release: val(item,'Release','release','Version','version'),
            revision: val(item,'Revision','revision'),
            status: primaryStatus,
            fallbackStatus,
            statusLabel,
            statusSince: val(item,'StatusSince','statusSince','StatusDate','statusDate','StatusChangedAt','statusChangedAt','StatusUpdatedAt','statusUpdatedAt'),
            installedAt: val(item,'InstalledAt','installedAt','InstalledOn','installedOn'),
            offeredAt: val(item,'OfferedAt','offeredAt','OfferedOn','offeredOn'),
            plannedStart: val(item,'PlannedWindowStart','plannedWindowStart','NextWindowStart','nextWindowStart','PlannedStart','plannedStart','WindowStart','windowStart'),
            plannedEnd: val(item,'PlannedWindowEnd','plannedWindowEnd','NextWindowEnd','nextWindowEnd','PlannedEnd','plannedEnd','WindowEnd','windowEnd'),
            createdAt: val(item,'CreatedAt','createdAt'),
            updatedAt: val(item,'UpdatedAt','updatedAt','LastUpdated','lastUpdated'),
            supportStart: val(item,'SupportStartDate','supportStartDate'),
            supportEnd: val(item,'SupportEndDate','supportEndDate'),
            supportPhase,
            lifecycleStatus,
            licenseModel: val(item,'LicenseModel','licenseModel'),
            thirdParty: val(item,'ThirdParty','thirdParty','IsThirdParty','isThirdParty'),
            vendorName: val(item,'Vendor','vendor','Manufacturer','manufacturer','Supplier','supplier'),
            notes: val(item,'Notes','notes','Comment','comment','Remarks','remarks','Description','description'),
            projectId: val(item,'ProjectID','projectID','projectId','ProjectId'),
            projectName: (val(item,'ProjectName','projectName') ?? '').toString().trim(),
            accountId: val(item,'AccountID','accountID','accountId','AccountId'),
            accountName: (val(item,'AccountName','accountName') ?? '').toString().trim(),
            fireZone: val(item,'FireZone','fireZone','Zone','zone'),
            tenantCount: val(item,'TenantCount','tenantCount'),
        };
    }

    function buildStatusBadgeHtml(statusValue, statusLabel){
        const base = statusValue ?? statusLabel;
        if(!base && !statusLabel) return '';
        const normalizedInstall = normalizeInstallStatus(base);
        if(INSTALL_STATUS_DISPLAY[normalizedInstall]){
            return renderInstallStatusBadge(base, statusLabel ?? INSTALL_STATUS_DISPLAY[normalizedInstall].label);
        }
        const normalizedLifecycle = normalizeLifecycleStatus(base);
        if(LIFECYCLE_STATUS_DISPLAY[normalizedLifecycle]){
            const label = statusLabel ?? LIFECYCLE_STATUS_DISPLAY[normalizedLifecycle].label;
            return `<span class="status-badge status-badge--${LIFECYCLE_STATUS_DISPLAY[normalizedLifecycle].tone}">${escapeHtml(label)}</span>`;
        }
        const label = statusLabel ?? base;
        return label ? `<span class="software-overview__status-text">${escapeHtml(label)}</span>` : '';
    }

    function appendStatusBadgeElement(container, entry){
        if(!container || !entry) return;
        const statusValue = entry.status ?? entry.fallbackStatus;
        const badgeHtml = buildStatusBadgeHtml(statusValue, entry.statusLabel);
        if(!badgeHtml) return;
        const wrapper = document.createElement('span');
        wrapper.innerHTML = badgeHtml;
        while(wrapper.firstChild){
            container.appendChild(wrapper.firstChild);
        }
    }

    function normalizeBoolean(value){
        if(value === undefined || value === null) return null;
        if(typeof value === 'boolean') return value;
        const normalized = value.toString().trim().toLowerCase();
        if(!normalized) return null;
        if(['true','1','yes','y','ja','on'].includes(normalized)) return true;
        if(['false','0','no','n','nein','off'].includes(normalized)) return false;
        return null;
    }

    function describeVendor(entry){
        if(!entry) return '';
        if(entry.vendorName){
            const label = entry.vendorName.toString().trim();
            if(label) return label;
        }
        const bool = normalizeBoolean(entry.thirdParty);
        if(bool === null) return '';
        return bool ? 'Third-party' : 'First-party';
    }

    function createEntityLink(type, id, label){
        if(!id) return null;
        const link = document.createElement('a');
        link.href = `/details.html?type=${encodeURIComponent(type)}&id=${encodeURIComponent(id)}`;
        link.textContent = (label ?? '').toString().trim() || `${type.charAt(0).toUpperCase()}${type.slice(1)} ${shortId(id).replace(/^##/, '#')}`;
        return link;
    }

    function appendMeta(metaList, label, value, options = {}){
        if(!metaList || !label) return;
        if(options.node instanceof Node){
            const li = document.createElement('li');
            const labelSpan = document.createElement('span');
            labelSpan.className = 'software-overview__meta-label';
            labelSpan.textContent = label;
            li.appendChild(labelSpan);
            li.appendChild(options.node);
            metaList.appendChild(li);
            return;
        }
        if(options.html){
            if(!value) return;
            const li = document.createElement('li');
            const labelSpan = document.createElement('span');
            labelSpan.className = 'software-overview__meta-label';
            labelSpan.textContent = label;
            li.appendChild(labelSpan);
            const wrapper = document.createElement('span');
            wrapper.innerHTML = value;
            if(!wrapper.hasChildNodes()){
                const text = wrapper.textContent.trim();
                if(!text) return;
                const textNode = document.createElement('span');
                textNode.textContent = text;
                li.appendChild(textNode);
            } else {
                while(wrapper.firstChild){
                    li.appendChild(wrapper.firstChild);
                }
            }
            metaList.appendChild(li);
            return;
        }
        if(value === undefined || value === null) return;
        const str = value.toString().trim();
        if(!str) return;
        const li = document.createElement('li');
        const labelSpan = document.createElement('span');
        labelSpan.className = 'software-overview__meta-label';
        labelSpan.textContent = label;
        li.appendChild(labelSpan);
        const valueSpan = document.createElement('span');
        valueSpan.textContent = str;
        li.appendChild(valueSpan);
        metaList.appendChild(li);
    }

    function buildSoftwareOverviewItem(entry, context){
        const item = document.createElement('div');
        item.className = 'software-overview__item';

        const header = document.createElement('div');
        header.className = 'software-overview__header';

        const isSoftwareContext = context === 'software';
        const linkType = isSoftwareContext ? 'site' : 'software';
        const linkId = isSoftwareContext ? entry.siteId : entry.softwareId;
        const displayName = (isSoftwareContext ? entry.siteDisplayName : entry.softwareDisplayName) || (isSoftwareContext ? entry.rawSiteName : entry.rawSoftwareName);
        const fallbackName = isSoftwareContext
            ? (entry.siteId ? `Site ${shortId(entry.siteId).replace(/^##/, '#')}` : 'Site')
            : (entry.softwareId ? `Software ${shortId(entry.softwareId).replace(/^##/, '#')}` : 'Software');
        const finalName = (displayName || '').toString().trim() || fallbackName;

        if(linkId){
            const anchor = document.createElement('a');
            anchor.className = 'software-overview__name';
            anchor.href = `/details.html?type=${encodeURIComponent(linkType)}&id=${encodeURIComponent(linkId)}`;
            anchor.textContent = finalName;
            header.appendChild(anchor);
        } else {
            const span = document.createElement('span');
            span.className = 'software-overview__name';
            span.textContent = finalName;
            header.appendChild(span);
        }

        const chipHtml = formatIdChip(linkId);
        if(chipHtml){
            const chipWrapper = document.createElement('span');
            chipWrapper.innerHTML = chipHtml;
            if(chipWrapper.firstChild){
                header.appendChild(chipWrapper.firstChild);
            }
        }

        if(!isSoftwareContext){
            const versionParts = [];
            if(entry.release) versionParts.push(`Release ${entry.release}`);
            if(entry.revision) versionParts.push(`Rev ${entry.revision}`);
            if(versionParts.length){
                const version = document.createElement('span');
                version.className = 'software-overview__version';
                version.textContent = versionParts.join(' · ');
                header.appendChild(version);
            }
        }

        appendStatusBadgeElement(header, entry);

        item.appendChild(header);

        const meta = document.createElement('ul');
        meta.className = 'software-overview__meta';

        appendMeta(meta, 'Status since', formatDateLabel(entry.statusSince));
        appendMeta(meta, 'Installed', formatDateLabel(entry.installedAt));
        appendMeta(meta, 'Offered', formatDateLabel(entry.offeredAt));
        appendMeta(meta, 'Planned window', formatDateRange(entry.plannedStart, entry.plannedEnd));
        appendMeta(meta, 'Support window', formatDateRange(entry.supportStart, entry.supportEnd));

        if(entry.supportPhase){
            const badge = renderLifecycleStatusBadge(entry.supportPhase);
            if(badge) appendMeta(meta, 'Support phase', badge, { html: true });
        }

        const vendor = describeVendor(entry);
        if(vendor) appendMeta(meta, 'Vendor', vendor);

        if(entry.licenseModel) appendMeta(meta, 'License', entry.licenseModel);
        appendMeta(meta, 'Updated', formatDateLabel(entry.updatedAt));
        appendMeta(meta, 'Created', formatDateLabel(entry.createdAt));

        if(isSoftwareContext){
            if(entry.release || entry.revision){
                const versionBits = [];
                if(entry.release) versionBits.push(`Release ${entry.release}`);
                if(entry.revision) versionBits.push(`Rev ${entry.revision}`);
                appendMeta(meta, 'Version', versionBits.join(' · '));
            }
            if(entry.fireZone) appendMeta(meta, 'Fire zone', entry.fireZone);
            if(entry.tenantCount !== undefined && entry.tenantCount !== null){
                appendMeta(meta, 'Tenants', entry.tenantCount);
            }
            if(entry.projectId || entry.projectName){
                const projectLink = createEntityLink('project', entry.projectId, entry.projectName);
                if(projectLink) appendMeta(meta, 'Project', null, { node: projectLink });
                else if(entry.projectName) appendMeta(meta, 'Project', entry.projectName);
            }
            if(entry.accountId || entry.accountName){
                const accountLink = createEntityLink('account', entry.accountId, entry.accountName);
                if(accountLink) appendMeta(meta, 'Account', null, { node: accountLink });
                else if(entry.accountName) appendMeta(meta, 'Account', entry.accountName);
            }
        }

        if(meta.childNodes.length){
            item.appendChild(meta);
        }

        const notes = (entry.notes ?? '').toString().trim();
        if(notes){
            const noteEl = document.createElement('p');
            noteEl.className = 'software-overview__notes';
            noteEl.textContent = notes;
            item.appendChild(noteEl);
        }

        return item;
    }

    function renderSoftwareOverviewSection(container, config = {}){
        if(!container) return;
        const context = config.context === 'software' ? 'software' : 'site';
        const title = config.title ?? 'Software Overview';
        const emptyMessage = config.emptyMessage ?? '(no entries)';
        const sourceItems = Array.isArray(config.items) ? config.items : [];

        const normalized = sourceItems
            .map(normalizeSoftwareOverviewEntry)
            .filter(entry => entry && (context === 'software' ? (entry.siteDisplayName || entry.siteId) : (entry.softwareDisplayName || entry.softwareId)));

        const section = document.createElement('div');
        section.className = 'section';

        const heading = document.createElement('h2');
        heading.innerHTML = `${escapeHtml(title)} <span class="count">(${normalized.length})</span>`;
        section.appendChild(heading);

        if(!normalized.length){
            const empty = document.createElement('div');
            empty.className = 'empty';
            empty.textContent = emptyMessage;
            section.appendChild(empty);
            container.appendChild(section);
            return;
        }

        const list = document.createElement('div');
        list.className = 'software-overview';
        normalized.forEach(entry => list.appendChild(buildSoftwareOverviewItem(entry, context)));
        section.appendChild(list);
        container.appendChild(section);
    }

    function normalizeAssignmentEntry(entry){
        if(!entry || typeof entry !== 'object') return null;
        const softwareId = val(entry,'softwareId','SoftwareID','softwareID');
        const installedSoftwareId = val(entry,'installedSoftwareId','InstalledSoftwareID','installationId');
        const status = val(entry,'status','Status');
        const offeredDate = val(entry,'offeredDate','offeredAt','OfferedDate','OfferedAt');
        const installedDate = val(entry,'installedDate','installedAt','InstalledDate','InstalledAt');
        const rejectedDate = val(entry,'rejectedDate','rejectedAt','RejectedDate','RejectedAt');
        const release = val(entry,'release','Release');
        const revision = val(entry,'revision','Revision');
        const softwareName = (val(entry,'softwareName','SoftwareName','name','Name') ?? '').toString().trim();
        if(!softwareId && !installedSoftwareId) return null;
        return { installedSoftwareId, softwareId, status, offeredDate, installedDate, rejectedDate, release, revision, softwareName };
    }

    function setSiteSoftwareAssignments(assignments){
        const normalized = Array.isArray(assignments)
            ? assignments.map(normalizeAssignmentEntry).filter(Boolean)
            : [];
        currentSiteSoftwareAssignments = normalized;
    }

    async function loadSoftwareOptions(){
        if(softwareOptionCache) return softwareOptionCache;
        if(softwareOptionLoadError) throw softwareOptionLoadError;
        const source = formConfig?.asyncSources?.software;
        if(!source || !source.url) return [];
        const url = typeof source.url === 'function' ? source.url() : source.url;
        const res = await fetch(url);
        if(!res.ok){
            const err = new Error(`HTTP ${res.status}`);
            softwareOptionLoadError = err;
            throw err;
        }
        const data = await res.json();
        const mapped = Array.isArray(data) ? data.map(item => (typeof source.map === 'function' ? source.map(item) : null)).filter(Boolean) : [];
        softwareOptionCache = mapped;
        return mapped;
    }

    async function ensureSoftwareOptionsList(form){
        if(!form) return;
        let list = form.querySelector('#software-options-list');
        if(!list){
            list = document.createElement('datalist');
            list.id = 'software-options-list';
            form.appendChild(list);
        }
        try{
            const options = await loadSoftwareOptions();
            list.innerHTML = options.map(opt => {
                const identifier = opt.value ?? '';
                const displayLabel = opt.displayLabel || opt.label || identifier;
                const secondary = identifier ? escapeHtml(identifier) : '';
                return `<option data-id="${escapeHtml(identifier)}" value="${escapeHtml(displayLabel)}" label="${escapeHtml(displayLabel)}">${secondary}</option>`;
            }).join('');
        }catch(err){
            console.error('Unable to load software options', err);
            list.innerHTML = '';
        }
    }

    function createSoftwareAssignmentRow(entry = {}){
        const normalized = normalizeAssignmentEntry(entry) || {};
        const row = document.createElement('div');
        row.className = 'software-assignment-row';
        if(normalized.installedSoftwareId){
            row.dataset.installationId = normalized.installedSoftwareId;
        }

        const softwareField = document.createElement('div');
        softwareField.className = 'software-assignment__field';
        const softwareLabel = document.createElement('label');
        softwareLabel.textContent = 'Software';
        const softwareHiddenInput = document.createElement('input');
        softwareHiddenInput.type = 'hidden';
        softwareHiddenInput.name = 'softwareId';
        softwareHiddenInput.value = normalized.softwareId || '';

        const softwareInput = document.createElement('input');
        softwareInput.type = 'text';
        softwareInput.name = 'softwareDisplay';
        softwareInput.required = true;
        softwareInput.setAttribute('list', 'software-options-list');
        softwareInput.placeholder = 'Select software';
        const displayParts = [normalized.softwareName, normalized.release, normalized.revision].filter(Boolean);
        const initialDisplay = displayParts.join(' • ');
        if(initialDisplay){
            softwareInput.value = initialDisplay;
        }else if(normalized.softwareId){
            const cachedMatch = softwareOptionCache?.find(opt => opt.value === normalized.softwareId);
            softwareInput.value = cachedMatch?.displayLabel || cachedMatch?.label || normalized.softwareId;
        }

        const syncSoftwareSelection = () => {
            const display = softwareInput.value.trim();
            let resolvedId = '';
            const listEl = softwareInput.list;
            if(listEl && display){
                const opts = Array.from(listEl.options || []);
                const match = opts.find(opt => opt.value === display);
                if(match){
                    resolvedId = match.dataset.id || match.getAttribute('data-id') || '';
                }
            }
            if(!resolvedId && display){
                resolvedId = display;
            }
            softwareHiddenInput.value = resolvedId;
        };
        softwareInput.addEventListener('change', syncSoftwareSelection);
        softwareInput.addEventListener('blur', syncSoftwareSelection);
        softwareInput.addEventListener('input', () => {
            if(!softwareInput.value.trim()){
                softwareHiddenInput.value = '';
            }
        });

        softwareField.appendChild(softwareLabel);
        softwareField.appendChild(softwareHiddenInput);
        softwareField.appendChild(softwareInput);
        if(normalized.softwareName || normalized.release || normalized.revision){
            const meta = document.createElement('div');
            meta.className = 'software-assignment__meta';
            const parts = [normalized.softwareName, normalized.release, normalized.revision].filter(Boolean);
            meta.textContent = parts.join(' • ');
            softwareField.appendChild(meta);
        }

        const statusField = document.createElement('div');
        statusField.className = 'software-assignment__field';
        const statusLabel = document.createElement('label');
        statusLabel.textContent = 'Status';
        const statusSelect = document.createElement('select');
        statusSelect.name = 'status';
        statusSelect.required = true;
        statusSelect.innerHTML = '<option value="">Select status…</option>';
        Object.entries(INSTALL_STATUS_DISPLAY).forEach(([key, meta]) => {
            const opt = document.createElement('option');
            opt.value = meta.label;
            opt.textContent = meta.label;
            statusSelect.appendChild(opt);
        });
        const normalizedStatus = normalizeInstallStatus(normalized.status);
        const match = INSTALL_STATUS_DISPLAY[normalizedStatus];
        if(match){
            statusSelect.value = match.label;
        }
        statusField.appendChild(statusLabel);
        statusField.appendChild(statusSelect);

        const offeredField = document.createElement('div');
        offeredField.className = 'software-assignment__field';
        const offeredLabel = document.createElement('label');
        offeredLabel.textContent = 'Offered';
        const offeredInput = document.createElement('input');
        offeredInput.type = 'date';
        offeredInput.name = 'offeredDate';
        offeredInput.value = formatInputValue(normalized.offeredDate, 'date');
        offeredField.appendChild(offeredLabel);
        offeredField.appendChild(offeredInput);

        const installedField = document.createElement('div');
        installedField.className = 'software-assignment__field';
        const installedLabel = document.createElement('label');
        installedLabel.textContent = 'Installed';
        const installedInput = document.createElement('input');
        installedInput.type = 'date';
        installedInput.name = 'installedDate';
        installedInput.value = formatInputValue(normalized.installedDate, 'date');
        installedField.appendChild(installedLabel);
        installedField.appendChild(installedInput);

        const rejectedField = document.createElement('div');
        rejectedField.className = 'software-assignment__field';
        const rejectedLabel = document.createElement('label');
        rejectedLabel.textContent = 'Rejected';
        const rejectedInput = document.createElement('input');
        rejectedInput.type = 'date';
        rejectedInput.name = 'rejectedDate';
        rejectedInput.value = formatInputValue(normalized.rejectedDate, 'date');
        rejectedField.appendChild(rejectedLabel);
        rejectedField.appendChild(rejectedInput);

        const actions = document.createElement('div');
        actions.className = 'software-assignment__actions';
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'software-assignment__remove';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', () => {
            row.remove();
        });
        actions.appendChild(removeBtn);

        const error = document.createElement('div');
        error.className = 'software-assignment__error';

        row.appendChild(softwareField);
        row.appendChild(statusField);
        row.appendChild(offeredField);
        row.appendChild(installedField);
        row.appendChild(rejectedField);
        row.appendChild(actions);
        row.appendChild(error);

        return row;
    }

    function renderSoftwareAssignmentEditor(container){
        if(!container) return;
        container.innerHTML = '';

        const title = document.createElement('h3');
        title.textContent = 'Software installations';
        container.appendChild(title);

        const list = document.createElement('div');
        list.className = 'software-assignment-list';
        if(!currentSiteSoftwareAssignments.length){
            const empty = document.createElement('div');
            empty.className = 'software-assignment__empty';
            empty.textContent = 'No software entries added yet.';
            list.appendChild(empty);
        }else{
            currentSiteSoftwareAssignments.forEach(entry => {
                list.appendChild(createSoftwareAssignmentRow(entry));
            });
        }
        container.appendChild(list);

        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'btn-secondary software-assignment__add';
        addBtn.textContent = 'Add software entry';
        addBtn.addEventListener('click', () => {
            const emptyState = list.querySelector('.software-assignment__empty');
            if(emptyState){
                emptyState.remove();
            }
            list.appendChild(createSoftwareAssignmentRow());
        });
        container.appendChild(addBtn);
    }

    function collectSoftwareAssignments(form){
        const list = form.querySelector('.software-assignment-list');
        if(!list) return [];
        const rows = Array.from(list.querySelectorAll('.software-assignment-row'));
        const assignments = [];
        let hasError = false;

        rows.forEach(row => {
            const softwareIdInput = row.querySelector('input[name="softwareId"]');
            const softwareDisplayInput = row.querySelector('input[name="softwareDisplay"]');
            const statusSelect = row.querySelector('select[name="status"]');
            const offeredInput = row.querySelector('input[name="offeredDate"]');
            const installedInput = row.querySelector('input[name="installedDate"]');
            const rejectedInput = row.querySelector('input[name="rejectedDate"]');
            const errorEl = row.querySelector('.software-assignment__error');
            if(errorEl){
                errorEl.textContent = '';
            }
            row.classList.remove('is-error');

            const softwareDisplay = (softwareDisplayInput?.value ?? '').trim();
            let softwareId = (softwareIdInput?.value ?? '').trim();
            const status = (statusSelect?.value ?? '').trim();
            const offeredDate = (offeredInput?.value ?? '').trim();
            const installedDate = (installedInput?.value ?? '').trim();
            const rejectedDate = (rejectedInput?.value ?? '').trim();

            if(!softwareId && softwareDisplay){
                const listEl = softwareDisplayInput?.list;
                if(listEl){
                    const match = Array.from(listEl.options || []).find(opt => opt.value === softwareDisplay);
                    if(match){
                        softwareId = match.dataset.id || match.getAttribute('data-id') || '';
                    }
                }
                if(!softwareId){
                    softwareId = softwareDisplay;
                }
            }

            if(!softwareId){
                if(errorEl) errorEl.textContent = 'Software is required.';
                row.classList.add('is-error');
                hasError = true;
                return;
            }
            if(!status){
                if(errorEl) errorEl.textContent = 'Status is required.';
                row.classList.add('is-error');
                hasError = true;
                return;
            }

            assignments.push({
                installedSoftwareId: row.dataset.installationId || null,
                softwareId,
                status,
                offeredDate: offeredDate || null,
                installedDate: installedDate || null,
                rejectedDate: rejectedDate || null
            });
        });

        if(hasError){
            return null;
        }
        return assignments;
    }

    async function renderSiteSoftwareOverview(siteId, targetEl, options = {}){
        if(!siteId || !targetEl) return;
        targetEl.innerHTML = '<div class="empty">Loading software overview…</div>';
        if(targetEl === siteSoftwareOverviewBody && siteSoftwareOverviewCard){
            siteSoftwareOverviewCard.hidden = false;
            siteSoftwareOverviewCard.setAttribute('aria-busy', 'true');
        }

        const prefetched = Array.isArray(options.items) ? options.items : null;
        let softwareOverview = prefetched ? mapSoftwareOverviewItems(prefetched) : [];
        if(!prefetched){
            try {
                softwareOverview = await fetchSoftwareOverview({ siteId });
            } catch (err){
                console.error('Software overview unavailable', err);
                targetEl.innerHTML = '<div class="empty">Software overview unavailable.</div>';
                if(targetEl === siteSoftwareOverviewBody && siteSoftwareOverviewCard){
                    siteSoftwareOverviewCard.removeAttribute('aria-busy');
                }
                return;
            }
        }

        targetEl.innerHTML = '';
        renderSoftwareOverviewSection(targetEl, {
            title: 'Software Overview',
            items: softwareOverview,
            context: 'site',
            emptyMessage: 'No software assignments recorded yet.'
        });

        if(targetEl === siteSoftwareOverviewBody && siteSoftwareOverviewCard){
            siteSoftwareOverviewCard.hidden = false;
            siteSoftwareOverviewCard.removeAttribute('aria-busy');
        }
    }

    function resetDetailRefs(){
        detailTitleEl = null;
        detailTypeEl = null;
        detailBodyEl = null;
        detailStatusEl = null;
        editButtonEl = null;
    }

    function ensureDetailLayout(){
        const hasElements = detailTitleEl?.isConnected && detailBodyEl?.isConnected && detailStatusEl?.isConnected && editButtonEl?.isConnected && detailTypeEl?.isConnected;
        if(hasElements) return;

        detailBox.innerHTML = '';

        const header = document.createElement('div');
        header.className = 'detail-header';

        const headerMain = document.createElement('div');
        headerMain.className = 'detail-header-main';

        detailTitleEl = document.createElement('h1');
        detailTitleEl.id = 'detail-title';
        headerMain.appendChild(detailTitleEl);

        detailTypeEl = document.createElement('span');
        detailTypeEl.className = 'detail-type-badge';
        detailTypeEl.setAttribute('aria-hidden', 'true');
        detailTypeEl.hidden = true;
        headerMain.appendChild(detailTypeEl);

        header.appendChild(headerMain);

        const actions = document.createElement('div');
        actions.className = 'detail-header-actions';

        editButtonEl = document.createElement('button');
        editButtonEl.type = 'button';
        editButtonEl.className = 'detail-edit-button';
        editButtonEl.setAttribute('aria-label', 'Edit entry');
        editButtonEl.innerHTML = '<svg class="detail-edit-icon" aria-hidden="true" focusable="false" viewBox="0 0 20 20"><path d="M2.5 13.79 2 17l3.21-.5 9.06-9.06-2.71-2.71-9.06 9.06ZM15.85 3.86c.39-.39.39-1.03 0-1.42l-1.29-1.29a1 1 0 0 0-1.42 0l-1.6 1.59 2.71 2.71 1.6-1.59Z"/></svg>';
        editButtonEl.addEventListener('click', () => {
            if(!currentRow) return;
            if(isEditing){
                exitEditMode();
            }else{
                enterEditMode();
            }
        });

        actions.appendChild(editButtonEl);
        header.appendChild(actions);
        detailBox.appendChild(header);

        detailStatusEl = document.createElement('div');
        detailStatusEl.id = 'detail-status';
        detailStatusEl.className = 'detail-status';
        detailStatusEl.setAttribute('role', 'status');
        detailStatusEl.setAttribute('aria-live', 'polite');
        detailStatusEl.setAttribute('aria-atomic', 'true');
        detailBox.appendChild(detailStatusEl);

        detailBodyEl = document.createElement('div');
        detailBodyEl.className = 'detail-body';
        detailBox.appendChild(detailBodyEl);
    }

    function updateModeIndicator(){
        if(!detailBox) return;
        detailBox.dataset.mode = isEditing ? 'edit' : 'view';
        if(isEditing){
            detailBox.classList.add('is-editing');
        }else{
            detailBox.classList.remove('is-editing');
        }
    }

    function updateEditButton(){
        ensureDetailLayout();
        if(!editButtonEl) return;
        editButtonEl.disabled = !currentRow;
        editButtonEl.setAttribute('aria-pressed', isEditing ? 'true' : 'false');
        editButtonEl.classList.toggle('is-active', !!isEditing);
        editButtonEl.title = isEditing ? 'Editing active' : 'Edit entry';
    }

    function setStatus(message, variant){
        ensureDetailLayout();
        const classes = ['detail-status'];
        if(message){
            classes.push('is-visible');
        }
        if(variant){
            classes.push(`detail-status--${variant}`);
        }
        detailStatusEl.className = classes.join(' ');
        detailStatusEl.textContent = message || '';
    }

    function clearStatus(){
        setStatus('', '');
    }

    function updateHeading(){
        ensureDetailLayout();
        if(!detailTitleEl) return { baseLabel: '', captionText: '' };
        const typeLabelRaw = currentRawType || currentTable || '';
        const typeLabel = typeLabelRaw ? typeLabelRaw.charAt(0).toUpperCase() + typeLabelRaw.slice(1) : 'Entry';
        const normalizedType = tableForType(typeLabelRaw || currentTable || '') || '';
        const explicitLabel = (labelFor(currentRawType, currentRow) ?? '').toString().trim();
        const baseLabel = explicitLabel || typeLabel;
        const headingLabel = escapeHtml(baseLabel);
        const idChip = formatIdChip(currentId);
        detailTitleEl.innerHTML = idChip ? `${headingLabel} ${idChip}` : headingLabel;
        if(detailTypeEl){
            const normalized = normalizedType ? normalizedType.toString().trim() : '';
            if(normalized){
                detailTypeEl.textContent = normalized;
                detailTypeEl.hidden = false;
                detailTypeEl.classList.add('is-visible');
            }else{
                detailTypeEl.textContent = '';
                detailTypeEl.hidden = true;
                detailTypeEl.classList.remove('is-visible');
            }
        }
        const captionIdRaw = (currentId ?? '').toString().trim();
        const captionId = captionIdRaw ? (captionIdRaw.startsWith('#') ? captionIdRaw : `#${captionIdRaw}`) : '';
        const captionText = captionId ? `${baseLabel} ${captionId}` : baseLabel;
        if(baseLabel){
            detailBox.setAttribute('aria-label', baseLabel);
            document.title = `${baseLabel} – ${defaultDocumentTitle}`;
        }else{
            detailBox.removeAttribute('aria-label');
            document.title = defaultDocumentTitle;
        }
        return { baseLabel, captionText };
    }

    function inferValueType(value){
        if(value === null || value === undefined) return 'text';
        if(typeof value === 'boolean') return 'boolean';
        if(typeof value === 'number') return 'number';
        if(typeof value === 'string'){
            const trimmed = value.trim();
            if(!trimmed) return 'text';
            const lowered = trimmed.toLowerCase();
            if(lowered === 'true' || lowered === 'false' || lowered === '1' || lowered === '0'){
                return 'boolean';
            }
            const datePattern = /^\d{4}-\d{2}-\d{2}$/;
            const dateTimePattern = /^\d{4}-\d{2}-\d{2}[T\s]/;
            if((datePattern.test(trimmed) || dateTimePattern.test(trimmed)) && !Number.isNaN(Date.parse(trimmed))){
                return 'date';
            }
        }
        return 'text';
    }

    function formatInputValue(value, type){
        if(value === null || value === undefined) return '';
        if(type === 'boolean'){
            if(typeof value === 'boolean') return value ? 'true' : 'false';
            const normalized = String(value).trim().toLowerCase();
            if(normalized === 'true' || normalized === '1') return 'true';
            if(normalized === 'false' || normalized === '0') return 'false';
            return '';
        }
        if(type === 'date'){
            const str = String(value).trim();
            const pureDate = /^\d{4}-\d{2}-\d{2}$/;
            if(pureDate.test(str)) return str;
            const parsed = Date.parse(str);
            if(!Number.isNaN(parsed)){
                const d = new Date(parsed);
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${y}-${m}-${day}`;
            }
            return str;
        }
        return String(value ?? '');
    }

    function renderViewMode(row){
        ensureDetailLayout();
        updateModeIndicator();
        updateEditButton();
        const { captionText } = updateHeading();
        const entries = Object.entries(row || {});
        const kvRows = entries
            .filter(([k]) => (k ?? '').toString().toLowerCase() !== 'softwareassignments')
            .map(([k,v]) => {
            const keyLabel = escapeHtml(k);
            const normalizedKey = (k ?? '').toString().trim().toLowerCase();
            let cellHtml;
            if(normalizedKey === 'lifecyclestatus'){
                cellHtml = renderLifecycleStatusBadge(v);
            }else{
                cellHtml = v === null || v === undefined ? '' : escapeHtml(String(v));
            }
            return `<tr><th scope="row" class="key">${keyLabel}</th><td>${cellHtml}</td></tr>`;
        }).join('');
        const tableHtml = `<table id="kv">
  <caption class="visually-hidden">Fields for ${escapeHtml(captionText)}</caption>
  ${kvRows}
</table>`;

        const configKey = configKeyForTable(currentTable);
        const isSiteDetail = configKey === 'Site';
        if(detailBox){
            detailBox.classList.toggle('card--wide', isSiteDetail);
        }
        if(detailLayoutEl){
            detailLayoutEl.classList.toggle('detail-layout--with-software', isSiteDetail && !!siteSoftwareOverviewCard && !!siteSoftwareOverviewBody);
        }

        detailBodyEl.innerHTML = tableHtml;

        if(isSiteDetail){
            if(siteSoftwareOverviewBody){
                siteSoftwareOverviewBody.innerHTML = '<div class="empty">Loading software overview…</div>';
            }
            if(siteSoftwareOverviewCard){
                if(siteSoftwareOverviewBody){
                    siteSoftwareOverviewCard.hidden = false;
                    siteSoftwareOverviewCard.setAttribute('aria-busy', 'true');
                }else{
                    siteSoftwareOverviewCard.hidden = true;
                    siteSoftwareOverviewCard.removeAttribute('aria-busy');
                }
            }
        }else{
            if(siteSoftwareOverviewBody){
                siteSoftwareOverviewBody.innerHTML = '';
            }
            if(siteSoftwareOverviewCard){
                siteSoftwareOverviewCard.hidden = true;
                siteSoftwareOverviewCard.removeAttribute('aria-busy');
            }
        }
    }

    function renderEditMode(row){
        ensureDetailLayout();
        updateModeIndicator();
        updateEditButton();
        updateHeading();

        detailAsyncSelectConfigs = {};
        detailBodyEl.innerHTML = '';

        const form = document.createElement('form');
        form.className = 'detail-edit-form';
        form.setAttribute('aria-label', 'Edit entry');

        const grid = document.createElement('div');
        grid.className = 'detail-form-grid';
        const pkName = currentTable ? PKS[currentTable] : null;

        const configKey = configKeyForTable(currentTable);
        if(detailBox){
            detailBox.classList.toggle('card--wide', configKey === 'Site');
        }
        if(detailLayoutEl){
            detailLayoutEl.classList.remove('detail-layout--with-software');
        }
        if(siteSoftwareOverviewBody){
            siteSoftwareOverviewBody.innerHTML = '';
        }
        if(siteSoftwareOverviewCard){
            siteSoftwareOverviewCard.hidden = true;
            siteSoftwareOverviewCard.removeAttribute('aria-busy');
        }
        const configFields = formConfig.getFields(configKey) || [];
        const usedKeys = new Set();
        let html = '';

        configFields.forEach(field => {
            const rowKey = field.name || field.rowKey || field.id;
            if(rowKey) usedKeys.add(rowKey.toLowerCase());
            const rawValue = rowKey ? val(row, rowKey) : undefined;
            const overrides = { name: rowKey };
            if(field.dataset) overrides.dataset = field.dataset;
            if(rawValue !== undefined && rawValue !== null){
                const hint = (field.inputType || field.type || '').toLowerCase();
                let valueType;
                if(field.component && field.component.toLowerCase()==='select'){
                    valueType=field.valueType || 'text';
                }else if(field.component && field.component.toLowerCase()==='asyncselect'){
                    valueType=field.valueType || 'text';
                }else if(hint==='number'){
                    valueType='number';
                }else if(hint==='date'){
                    valueType='date';
                }else{
                    valueType=inferValueType(rawValue);
                }
                overrides.valueType = valueType;
                overrides.value = formatInputValue(rawValue, valueType);
            }else if(field.component && field.component.toLowerCase()==='asyncselect'){
                overrides.valueType = field.valueType || 'text';
            }
            html += renderFieldForDetails(field, overrides);
        });

        grid.innerHTML = html;

        Object.entries(row || {}).forEach(([key, value]) => {
            if(usedKeys.has(key.toLowerCase())) return;
            const inputId = `field-${key}`;
            const label = document.createElement('label');
            label.className = 'detail-field';
            label.setAttribute('for', inputId);

            const labelText = document.createElement('span');
            labelText.className = 'detail-field-label';
            labelText.textContent = key;

            const valueType = inferValueType(value);
            const formattedValue = formatInputValue(value, valueType);
            let input;

            if(valueType === 'boolean'){
                const select = document.createElement('select');
                select.id = inputId;
                select.name = key;
                select.className = 'detail-input';
                select.dataset.valueType = 'boolean';

                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Not set';
                select.appendChild(emptyOption);

                const trueOption = document.createElement('option');
                trueOption.value = 'true';
                trueOption.textContent = 'Yes';
                select.appendChild(trueOption);

                const falseOption = document.createElement('option');
                falseOption.value = 'false';
                falseOption.textContent = 'No';
                select.appendChild(falseOption);

                select.value = formattedValue || '';
                input = select;
            }else{
                const textInput = document.createElement('input');
                textInput.id = inputId;
                textInput.name = key;
                textInput.className = 'detail-input';
                textInput.dataset.valueType = valueType;
                if(valueType === 'number'){
                    textInput.type = 'number';
                    textInput.step = 'any';
                }else if(valueType === 'date'){
                    textInput.type = 'date';
                }else{
                    textInput.type = 'text';
                }
                textInput.value = formattedValue;
                input = textInput;
            }

            input.required = false;

            if(pkName && pkName.toLowerCase() === key.toLowerCase()){
                if(input.tagName === 'INPUT'){
                    input.readOnly = true;
                    input.setAttribute('aria-readonly', 'true');
                }else{
                    input.disabled = true;
                    input.setAttribute('aria-disabled', 'true');
                }
                input.classList.add('detail-input-readonly');
            }

            label.appendChild(labelText);
            label.appendChild(input);
            grid.appendChild(label);
        });

        form.appendChild(grid);

        if(configKey === 'Site'){
            const assignmentPanel = document.createElement('div');
            assignmentPanel.className = 'software-assignment-panel';
            renderSoftwareAssignmentEditor(assignmentPanel);
            form.appendChild(assignmentPanel);
            ensureSoftwareOptionsList(form);
        }

        const actions = document.createElement('div');
        actions.className = 'detail-form-actions';

        const saveButton = document.createElement('button');
        saveButton.type = 'submit';
        saveButton.className = 'btn-primary';
        saveButton.textContent = 'Save';

        const cancelButton = document.createElement('button');
        cancelButton.type = 'button';
        cancelButton.className = 'btn-secondary';
        cancelButton.textContent = 'Cancel';
        cancelButton.addEventListener('click', () => {
            exitEditMode();
        });

        actions.appendChild(saveButton);
        actions.appendChild(cancelButton);
        form.appendChild(actions);

        form.addEventListener('submit', event => {
            event.preventDefault();
            saveForm(form, saveButton);
        });

        detailBodyEl.appendChild(form);

        detailInitializeAsyncSelects(form);
        detailApplyInputEnhancements(form);
        detailApplyValidationMessages(form);

        const focusTarget = form.querySelector('input:not([readonly]), select, textarea');
        if(focusTarget){
            focusTarget.focus();
        }
    }

    function renderDetail(){
        if(!currentRow){
            updateEditButton();
            return;
        }
        if(isEditing){
            renderEditMode(currentRow);
        }else{
            renderViewMode(currentRow);
        }
    }

    function enterEditMode(){
        if(!currentRow) return;
        isEditing = true;
        renderDetail();
    }

    async function exitEditMode(){
        if(!currentRow) return;
        isEditing = false;
        await loadData({ preserveStatus: true });
    }

    async function saveForm(form, saveButton){
        if(!currentTable || !currentId) return;

        const payload = {};
        const elements = Array.from(form.querySelectorAll('input, select, textarea'));
        for(const el of elements){
            if(!el.name || el.disabled) continue;
            const type = el.dataset.valueType;
            if(type === 'number'){
                if(el.value === ''){
                    payload[el.name] = null;
                }else{
                    const num = Number(el.value);
                    if(Number.isNaN(num)){
                        setStatus(`Field ${el.name} must be a number.`, 'error');
                        return;
                    }
                    payload[el.name] = num;
                }
            }else if(type === 'date'){
                payload[el.name] = el.value === '' ? null : el.value;
            }else if(type === 'boolean'){
                if(el.value === ''){
                    payload[el.name] = null;
                }else{
                    const normalized = String(el.value).trim().toLowerCase();
                    if(normalized === 'true' || normalized === '1'){
                        payload[el.name] = true;
                    }else if(normalized === 'false' || normalized === '0'){
                        payload[el.name] = false;
                    }else{
                        setStatus(`Field ${el.name} expects a true/false value.`, 'error');
                        return;
                    }
                }
            }else{
                payload[el.name] = el.value;
            }
        }

        const entityKey = configKeyForTable(currentTable);
        const normalizeEmpty = (value) => {
            if(value === undefined || value === null) return null;
            const str = String(value);
            return str === '' ? null : value;
        };
        let requestUrl = `/row/${currentTable}/${encodeURIComponent(currentId)}`;
        let requestPayload = payload;
        const fail = msg => {
            setStatus(msg, 'error');
            return true;
        };

        if(entityKey === 'Country'){
            if(payload.CountryCode !== undefined && payload.CountryCode !== null){
                const code = String(payload.CountryCode).trim().toUpperCase();
                if(code.length !== 2){
                if(fail('Country code must be exactly 2 characters.')) return;
                }
                payload.CountryCode = code;
            }
        }else if(entityKey === 'City'){
            if(payload.CountryCode === undefined || payload.CountryCode === null || payload.CountryCode === ''){
                if(fail('Please select a country.')) return;
            }else{
                payload.CountryCode = String(payload.CountryCode).trim().toUpperCase();
            }
            if(payload.CityID !== undefined && payload.CityID !== null){
                payload.CityID = String(payload.CityID).trim().toUpperCase();
            }
        }else if(entityKey === 'Site'){
            if(Object.prototype.hasOwnProperty.call(payload,'TenantCount') && payload.TenantCount !== null){
                const num = Number(payload.TenantCount);
                if(Number.isNaN(num)){
                    if(fail('TenantCount must be a number.')) return;
                }
                payload.TenantCount = num;
            }
            const assignments = collectSoftwareAssignments(form);
            if(assignments === null){
                setStatus('Please resolve the highlighted software entries.', 'error');
                return;
            }
            requestUrl = `/sites/${encodeURIComponent(currentId)}`;
            requestPayload = {
                siteName: normalizeEmpty(payload.SiteName ?? payload.siteName),
                projectID: normalizeEmpty(payload.ProjectID ?? payload.projectID),
                addressID: normalizeEmpty(payload.AddressID ?? payload.addressID),
                fireZone: normalizeEmpty(payload.FireZone ?? payload.fireZone),
                tenantCount: payload.TenantCount ?? payload.tenantCount ?? null,
                softwareAssignments: assignments
            };
        }else if(entityKey === 'UpgradePlan'){
            const start = payload.PlannedWindowStart;
            const end = payload.PlannedWindowEnd;
            if(start && end && start > end){
                if(fail('The planned end must be after the start.')) return;
            }
        }else if(entityKey === 'ServiceContract'){
            const start = payload.StartDate;
            const end = payload.EndDate;
            if(start && end && start > end){
                if(fail('End date cannot be before the start date.')) return;
            }
        }else if(entityKey === 'AudioDevice'){
            if(Object.prototype.hasOwnProperty.call(payload, 'DeviceType') || Object.prototype.hasOwnProperty.call(payload, 'deviceType')){
                const raw = payload.DeviceType ?? payload.deviceType;
                if(raw === null || raw === undefined || raw === ''){
                    if(fail('DeviceType must be one of HEADSET, SPEAKER, MIC.')) return;
                }else{
                    const normalized = String(raw).trim().toUpperCase();
                    if(!ALLOWED_AUDIO_DEVICE_TYPES.has(normalized)){
                        if(fail('DeviceType must be one of HEADSET, SPEAKER, MIC.')) return;
                    }
                    payload.DeviceType = normalized;
                }
            }
        }

        setStatus('Saving changes …', 'info');
        saveButton.disabled = true;
        if(editButtonEl) editButtonEl.disabled = true;

        try{
            const res = await fetch(requestUrl, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestPayload)
            });
            if(!res.ok){
                const text = await res.text();
                throw new Error(text || res.statusText);
            }
            setStatus('Changes saved.', 'success');
            isEditing = false;
            await loadData({ preserveStatus: true });
        }catch(err){
            setStatus(`Error saving: ${err.message}`, 'error');
        }finally{
            saveButton.disabled = false;
            if(editButtonEl) editButtonEl.disabled = false;
        }
    }

    async function loadData(options){
        if(!currentTable || !currentId) return;
        const preserveStatus = options && options.preserveStatus;
        currentSiteSoftwareAssignments = [];

        detailBox.setAttribute('aria-busy', 'true');
        try{
            const configKey = configKeyForTable(currentTable);
            if(configKey === 'Site'){
                const res = await fetch(`/sites/${encodeURIComponent(currentId)}/detail`);
                if(!res.ok){
                    resetDetailRefs();
                    detailBox.textContent = res.status === 404 ? 'Entry not found.' : 'Error loading data.';
                    return;
                }
                const detail = await res.json();
                setSiteSoftwareAssignments(detail?.softwareAssignments);
                const { softwareAssignments, ...siteRow } = detail || {};
                currentRow = siteRow;
            }else{
                const res = await fetch(`/row/${currentTable}/${encodeURIComponent(currentId)}`);
                if(!res.ok){
                    resetDetailRefs();
                    if(res.status === 404){
                        detailBox.textContent = 'Entry not found.';
                    }else{
                        detailBox.textContent = 'Error loading data.';
                    }
                    return;
                }
                const row = await res.json();
                currentRow = row;
            }
            if(!preserveStatus) clearStatus();
            renderDetail();

            const typeKey = (currentTable === 'Clients') ? 'Client' : currentTable;
            await loadParents(typeKey, currentId, currentRow);
            await loadChildren(typeKey, currentId, currentRow);
        }catch(e){
            resetDetailRefs();
            detailBox.textContent = 'Error: ' + e;
        }finally{
            detailBox.removeAttribute('aria-busy');
        }
    }

    /* -------------------- Load parents -------------------- */
    async function loadParents(type, id, row){
        const box = parentsBox;
        box.innerHTML = '';

        // Helper functions for row fetches
        const rowAccount           = async (accountId)  => await fetchJson(`/row/Account/${accountId}`);
        const rowProject           = async (projectId)  => await fetchJson(`/row/Project/${projectId}`);
        const rowSite              = async (siteId)     => await fetchJson(`/row/Site/${siteId}`);
        const rowClient            = async (clientId)   => await fetchJson(`/row/Clients/${clientId}`); // changed
        const rowCity              = async (cityId)     => await fetchJson(`/row/City/${encodeURIComponent(cityId)}`);
        const rowSoftware          = async (softwareId) => await fetchJson(`/row/Software/${encodeURIComponent(softwareId)}`);
        const rowDeploymentVariant = async (variantId)  => await fetchJson(`/row/DeploymentVariant/${encodeURIComponent(variantId)}`);

        const sections = [];

        if (type === 'Project') {
            const pills = [];

            const accId = val(row,'AccountID');
            if (accId != null) {
                const acc = await rowAccount(accId);
                if (acc) {
                    pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                }
            }

            const variantId = val(row,'DeploymentVariantID');
            if (variantId != null) {
                const variant = await rowDeploymentVariant(variantId);
                if (variant) {
                    pills.push(pillLink(
                        `/details.html?type=deploymentvariant&id=${encodeURIComponent(variantId)}`,
                        'Deployment Variant',
                        variantId,
                        labelFor('deploymentvariant', variant)
                    ));
                }
            }

            if (pills.length) {
                sections.push({
                    title: 'Belongs to',
                    pills
                });
            }
        } else if (type === 'Site') {
            const projId = val(row,'ProjectID');
            if (projId != null) {
                const proj = await rowProject(projId);
                const pills = [];
                if (proj) {
                    pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
                    const accId = val(proj,'AccountID');
                    if (accId != null) {
                        const acc = await rowAccount(accId);
                        if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                    }
                }
                if (pills.length) sections.push({ title: 'Belongs to', pills });
            }
        } else if (type === 'Server') {
            const siteId = val(row,'SiteID');
            if (siteId != null) {
                const site = await rowSite(siteId);
                const pills = [];
                if (site) {
                    pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
                    const projId = val(site,'ProjectID');
                    if (projId != null) {
                        const proj = await rowProject(projId);
                        if (proj) {
                            pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
                            const accId = val(proj,'AccountID');
                            if (accId != null) {
                                const acc = await rowAccount(accId);
                                if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                            }
                        }
                    }
                }
                if (pills.length) sections.push({ title: 'Belongs to', pills });
            }
        } else if (type === 'Client') {
            const siteId = val(row,'SiteID');
            if (siteId != null) {
                const site = await rowSite(siteId);
                const pills = [];
                if (site) {
                    pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
                    const projId = val(site,'ProjectID');
                    if (projId != null) {
                        const proj = await rowProject(projId);
                        if (proj) {
                            pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
                            const accId = val(proj,'AccountID');
                            if (accId != null) {
                                const acc = await rowAccount(accId);
                                if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                            }
                        }
                    }
                }
                if (pills.length) sections.push({ title: 'Belongs to', pills });
            }
        } else if (type === 'PhoneIntegration') {
            const pills = [];
            const clientId = val(row,'ClientID');
            if (clientId != null) {
                const client = await rowClient(clientId);
                if (client) {
                    pills.push(pillLink(`/details.html?type=client&id=${clientId}`, 'Client', clientId, labelFor('client', client)));
                    const siteId = val(client,'SiteID');
                    if (siteId != null) {
                        const site = await rowSite(siteId);
                        if (site) {
                            pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
                            const projId = val(site,'ProjectID');
                            if (projId != null) {
                                const proj = await rowProject(projId);
                                if (proj) {
                                    pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
                                    const accId = val(proj,'AccountID');
                                    if (accId != null) {
                                        const acc = await rowAccount(accId);
                                        if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (pills.length) sections.push({ title: 'Belongs to', pills });
        } else if (type === 'City') {
            const countryCode = val(row, 'CountryCode');
            if (countryCode != null) {
                const country = await fetchJson(`/row/Country/${countryCode}`);
                if (country) {
                    const pill = pillLink(
                        `/details.html?type=country&id=${encodeURIComponent(countryCode)}`,
                        'Country',
                        countryCode,
                        labelFor('country', country)
                    );
                    sections.push({ title: 'Belongs to', pills: [pill] });
                }
            }
        } else if (type === 'Address') {
            const cityId = val(row, 'CityID');
            const pills = [];
            if (cityId != null) {
                const city = await rowCity(cityId);
                if (city) {
                    pills.push(pillLink(`/details.html?type=city&id=${encodeURIComponent(cityId)}`, 'City', cityId, labelFor('city', city)));
                    const countryCode = val(city, 'CountryCode') ?? val(row, 'CountryCode');
                    if (countryCode != null) {
                        const country = await fetchJson(`/row/Country/${encodeURIComponent(countryCode)}`);
                        if (country) {
                            pills.push(pillLink(`/details.html?type=country&id=${encodeURIComponent(countryCode)}`, 'Country', countryCode, labelFor('country', country)));
                        }
                    }
                }
            }
            if (pills.length) sections.push({ title: 'Belongs to', pills });
        } else if (type === 'Radio') {
            const pills = [];
            const siteId = val(row,'SiteID');
            if (siteId != null) {
                const site = await rowSite(siteId);
                if (site) {
                    pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
                    const projId = val(site,'ProjectID');
                    if (projId != null) {
                        const proj = await rowProject(projId);
                        if (proj) {
                            pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
                            const accId = val(proj,'AccountID');
                            if (accId != null) {
                                const acc = await rowAccount(accId);
                                if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                            }
                        }
                    }
                }
            }
            const clientId = val(row,'AssignedClientID');
            if (clientId != null) {
                const client = await rowClient(clientId);
                if (client) pills.push(pillLink(`/details.html?type=client&id=${clientId}`, 'Client', clientId, labelFor('client', client)));
            }
            if (pills.length) sections.push({ title: 'Belongs to', pills });
        } else if (type === 'Audio') {
            const clientId = val(row,'ClientID');
            if (clientId != null) {
                const client = await rowClient(clientId);
                const pills = [];
                if (client) {
                    pills.push(pillLink(`/details.html?type=client&id=${clientId}`, 'Client', clientId, labelFor('client', client)));
                    const siteId = val(client,'SiteID');
                    if (siteId != null) {
                        const site = await rowSite(siteId);
                        if (site) {
                            pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
                            const projId = val(site,'ProjectID');
                            if (projId != null) {
                                const proj = await rowProject(projId);
                                if (proj) {
                                    pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
                                    const accId = val(proj,'AccountID');
                                    if (accId != null) {
                                        const acc = await rowAccount(accId);
                                        if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                                    }
                                }
                            }
                        }
                    }
                }
                if (pills.length) sections.push({ title: 'Belongs to', pills });
            }
        } else if (type === 'Phone') {
            const clientId = val(row,'ClientID');
            if (clientId != null) {
                const client = await rowClient(clientId);
                const pills = [];
                if (client) {
                    pills.push(pillLink(`/details.html?type=client&id=${clientId}`, 'Client', clientId, labelFor('client', client)));
                    const siteId = val(client,'SiteID');
                    if (siteId != null) {
                        const site = await rowSite(siteId);
                        if (site) {
                            pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
                            const projId = val(site,'ProjectID');
                            if (projId != null) {
                                const proj = await rowProject(projId);
                                if (proj) {
                                    pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
                                    const accId = val(proj,'AccountID');
                                    if (accId != null) {
                                        const acc = await rowAccount(accId);
                                        if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                                    }
                                }
                            }
                        }
                    }
                }
                if (pills.length) sections.push({ title: 'Belongs to', pills });
            }
        } else if (type === 'ServiceContract') {
            const pills = [];
            const accId = val(row,'AccountID');
            if (accId != null) {
                const acc = await rowAccount(accId);
                if (acc) pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
            }
            const projId = val(row,'ProjectID');
            if (projId != null) {
                const proj = await rowProject(projId);
                if (proj) pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project', proj)));
            }
            const siteId = val(row,'SiteID');
            if (siteId != null) {
                const site = await rowSite(siteId);
                if (site) pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
            }
            if (pills.length) sections.push({ title: 'Belongs to', pills });
        } else if (type === 'UpgradePlan') {
            const pills = [];

            const siteId = val(row,'SiteID');
            let site = null;
            if (siteId != null) {
                site = await rowSite(siteId);
                if (site) {
                    pills.push(pillLink(`/details.html?type=site&id=${siteId}`, 'Site', siteId, labelFor('site', site)));
                }
            }

            let proj = null;
            let projId = val(row,'ProjectID');
            if (!projId && site) {
                projId = val(site,'ProjectID');
            }
            if (projId != null) {
                proj = await rowProject(projId);
                if (proj) {
                    pills.push(pillLink(`/details.html?type=project&id=${projId}`, 'Project', projId, labelFor('project',proj)));
                }
            }

            let accId = val(row,'AccountID');
            if (!accId && proj) {
                accId = val(proj,'AccountID');
            }
            if (accId != null) {
                const acc = await rowAccount(accId);
                if (acc) {
                    pills.push(pillLink(`/details.html?type=account&id=${accId}`, 'Account', accId, labelFor('account', acc)));
                }
            }

            const softwareId = val(row,'SoftwareID');
            if (softwareId != null) {
                const software = await rowSoftware(softwareId);
                if (software) {
                    pills.push(pillLink(`/details.html?type=software&id=${encodeURIComponent(softwareId)}`, 'Software', softwareId, labelFor('software', software)));
                }
            }

            if (pills.length) sections.push({ title: 'Belongs to', pills });
        }

        // Render sections
        if (sections.length){
            sections.forEach(s => {
                const sec = document.createElement('div');
                sec.className = 'section';
                sec.innerHTML = `<h2>${s.title}</h2>`;
                const wrap = document.createElement('div');
                s.pills.forEach(p => wrap.appendChild(p));
                sec.appendChild(wrap);
                box.appendChild(sec);
            });
        }
    }

    /* -------------------- Load children -------------------- */
    async function loadChildren(type, id, row){
        row = row || {};
        const box = childrenBox;
        box.innerHTML = '';

        const loadServiceContracts = async (filters = {}) => {
            const params = new URLSearchParams();
            const addIfPresent = (key, value) => {
                if (value === null || value === undefined) return;
                const str = value.toString().trim();
                if (str) params.set(key, str);
            };

            addIfPresent('accountId', filters.accountId);
            addIfPresent('projectId', filters.projectId);
            addIfPresent('siteId', filters.siteId);

            if (!params.toString()) return [];

            const rows = await fetchJson(`/servicecontracts?${params.toString()}`);
            return Array.isArray(rows) ? rows : [];
        };

        if(type==='Account'){
            const projects = await fetchJson(`/projects?accountId=${id}`);
            addSection(box, 'Projects', projects, p => {
                const pid = val(p,'ProjectID');
                const name = val(p,'ProjectName');
                return pillLink(`/details.html?type=project&id=${encodeURIComponent(pid)}`, null, pid, name);
            }, { entity: 'Project', label: 'Project', params: { accountId: id } });

            const contracts = await loadServiceContracts({ accountId: id });
            addSection(box, 'Service Contracts', contracts, sc => {
                const cid = val(sc,'ContractID');
                const label = val(sc,'ContractNumber');
                const status = val(sc,'Status');
                const meta = formatDateRange(val(sc,'StartDate'), val(sc,'EndDate'));
                const desc = [status, meta].filter(Boolean).join(' · ');
                return pillLink(`/details.html?type=servicecontract&id=${encodeURIComponent(cid)}`, labelFor('servicecontract', sc), cid, desc);
            }, { entity: 'ServiceContract', label: 'ServiceContract', params: { accountId: id } });
        }
        else if(type==='Project'){
            const sites = await fetchJson(`/sites?projectId=${id}`);
            addSection(box, 'Sites', sites, s => {
                const sid = val(s,'SiteID');
                const name = val(s,'SiteName');
                return pillLink(`/details.html?type=site&id=${encodeURIComponent(sid)}`, null, sid, name);
            }, { entity: 'Site', label: 'Site', params: { projectId: id } });

            const contracts = await loadServiceContracts({ accountId: val(row,'AccountID'), projectId: id });
            addSection(box, 'Service Contracts', contracts, sc => {
                const cid = val(sc,'ContractID');
                const label = val(sc,'ContractNumber');
                const status = val(sc,'Status');
                const meta = formatDateRange(val(sc,'StartDate'), val(sc,'EndDate'));
                const desc = [status, meta].filter(Boolean).join(' · ');
                return pillLink(`/details.html?type=servicecontract&id=${encodeURIComponent(cid)}`, labelFor('servicecontract', sc), cid, desc);
            }, { entity: 'ServiceContract', label: 'ServiceContract', params: { accountId: val(row,'AccountID'), projectId: id } });
        }
        else if(type==='DeploymentVariant'){
            const projectRows = await fetchJson(`/table/project?limit=200`);
            const projects = Array.isArray(projectRows)
                ? projectRows.filter(p => (val(p,'DeploymentVariantID') ?? '').toString() === (id ?? '').toString())
                : [];
            addSection(box, 'Projects', projects, p => {
                const pid = val(p,'ProjectID');
                const name = val(p,'ProjectName');
                return pillLink(`/details.html?type=project&id=${encodeURIComponent(pid)}`, null, pid, name);
            }, { entity: 'Project', label: 'Project', params: { deploymentVariantId: id } });
        }
        else if(type==='Country'){
            const codeRaw = val(row, 'CountryCode') ?? id;
            const normalizedCode = codeRaw ? String(codeRaw).toUpperCase() : '';
            const cities = normalizedCode ? await fetchJson(`/cities?countryCode=${encodeURIComponent(normalizedCode)}`) : [];
            const cityList = Array.isArray(cities)
                ? cities.filter(city => val(city, 'CityID') != null)
                : [];
            addSection(box, 'Cities', cityList, city => {
                const cityId = val(city, 'CityID');
                const label = labelFor('city', city);
                return pillLink(`/details.html?type=city&id=${encodeURIComponent(cityId)}`, label, cityId, null);
            }, { entity: 'City', label: 'City', params: { countryCode: normalizedCode } });
        }
        else if(type==='City'){
            const addressRows = await fetchJson(`/table/address?limit=200`);
            const addresses = Array.isArray(addressRows)
                ? addressRows.filter(a => (val(a,'CityID') ?? '').toString() === (id ?? '').toString())
                    .filter(a => val(a,'AddressID') != null)
                : [];
            addSection(box, 'Addresses', addresses, address => {
                const addressId = val(address,'AddressID');
                const label = labelFor('address', address);
                return pillLink(`/details.html?type=address&id=${encodeURIComponent(addressId)}`, label, addressId, null);
            }, { entity: 'Address', label: 'Address', params: { cityId: id } });
        }
        else if(type==='Site'){
            let projectId = val(row,'ProjectID');
            let accountId = val(row,'AccountID');
            if(!accountId && projectId){
                const projectRow = await fetchJson(`/row/Project/${encodeURIComponent(projectId)}`);
                if(projectRow) accountId = val(projectRow,'AccountID');
            }

            const servers = await fetchJson(`/servers?siteId=${id}`);
            addSection(box, 'Server', servers, s => {
                const sid = val(s,'ServerID');
                const name = val(s,'ServerName');
                return pillLink(`/details.html?type=server&id=${encodeURIComponent(sid)}`, null, sid, name);
            }, { entity: 'Server', label: 'Server', params: { accountId, projectId, siteId: id } });

            const clients = await fetchJson(`/clients?siteId=${id}`);
            addSection(box, 'Clients', clients, c => {
                const cid = val(c,'ClientID','clientID','ClientId','WorkingPositionID');
                const label = labelFor('client', c);
                return pillLink(`/details.html?type=client&id=${encodeURIComponent(cid ?? '')}`, label, cid, null);
            }, { entity: 'WorkingPosition', label: 'Client', params: { accountId, projectId, siteId: id } });

            const radios = await fetchJson(`/radios?siteId=${id}`);
            addSection(box, 'Radios', radios, r => {
                const rid = val(r,'RadioID');
                const brand = val(r,'RadioBrand');
                return pillLink(`/details.html?type=radio&id=${encodeURIComponent(rid)}`, null, rid, brand);
            }, { entity: 'Radio', label: 'Radio', params: { accountId, projectId, siteId: id } });

            const contracts = await loadServiceContracts({ accountId, projectId, siteId: id });
            addSection(box, 'Service Contracts', contracts, sc => {
                const cid = val(sc,'ContractID');
                const label = val(sc,'ContractNumber');
                const status = val(sc,'Status');
                const meta = formatDateRange(val(sc,'StartDate'), val(sc,'EndDate'));
                const desc = [status, meta].filter(Boolean).join(' · ');
                return pillLink(`/details.html?type=servicecontract&id=${encodeURIComponent(cid)}`, labelFor('servicecontract', sc), cid, desc);
            }, { entity: 'ServiceContract', label: 'ServiceContract', params: { accountId, projectId, siteId: id } });

            const softwareTarget = siteSoftwareOverviewBody || document.createElement('div');
            if(!siteSoftwareOverviewBody){
                box.appendChild(softwareTarget);
            }
            await renderSiteSoftwareOverview(id, softwareTarget, { items: currentSiteSoftwareAssignments });

            const upgradeRows = await fetchJson(`/table/upgradeplan?limit=200`);
            const plans = Array.isArray(upgradeRows)
                ? upgradeRows.filter(plan => (val(plan,'SiteID') ?? '').toString() === (id ?? '').toString())
                : [];
            addSection(box, 'Upgrade Plans', plans, plan => {
                const planId = val(plan,'UpgradePlanID');
                const label = labelFor('upgradeplan', plan);
                const status = val(plan,'Status');
                const softwareId = val(plan,'SoftwareID');
                const window = formatDateRange(val(plan,'PlannedWindowStart'), val(plan,'PlannedWindowEnd'));
                const descParts = [];
                if(status) descParts.push(status);
                if(softwareId) descParts.push(`Software ${shortId(softwareId).replace(/^##/, '#')}`);
                if(window) descParts.push(window);
                return pillLink(
                    `/details.html?type=upgradeplan&id=${encodeURIComponent(planId)}`,
                    label,
                    planId,
                    descParts.join(' · ')
                );
            }, { entity: 'UpgradePlan', label: 'Upgrade Plan', params: { siteId: id } });
        }
        else if(type==='Client'){
            const aud = await fetchJson(`/audio?clientId=${id}`);
            addSection(box, 'Audio Devices', aud, a => {
                const aid = val(a,'AudioDeviceID');
                const brand = val(a,'AudioDeviceBrand');
                return pillLink(`/details.html?type=audio&id=${encodeURIComponent(aid)}`, null, aid, brand);
            }, { entity: 'AudioDevice', label: 'AudioDevice', params: { clientId: id, siteId: val(row,'SiteID') } });

            const ph = await fetchJson(`/phones?clientId=${id}`);
            addSection(box, 'Phone Integrations', ph, p => {
                const pid = val(p,'PhoneIntegrationID');
                const brand = val(p,'PhoneBrand');
                return pillLink(`/details.html?type=phone&id=${encodeURIComponent(pid)}`, null, pid, brand);
            }, { entity: 'PhoneIntegration', label: 'PhoneIntegration', params: { clientId: id, siteId: val(row,'SiteID') } });
        }
        else if(type==='Software'){
            const softwareContextLabel = (() => {
                const name = val(row,'Name');
                const release = val(row,'Release');
                const revision = val(row,'Revision');
                const parts = [name, release, revision].map(part => (part ?? '').toString().trim()).filter(Boolean);
                return parts.length ? parts.join(' ') : '';
            })();

            const deploymentOverview = await fetchSoftwareOverview({ softwareId: id });
            renderSoftwareOverviewSection(box, {
                title: 'Deployments',
                items: deploymentOverview,
                context: 'software',
                emptyMessage: 'No deployments recorded for this software.'
            });

            const planRows = await fetchJson(`/table/upgradeplan?limit=200`);
            const plans = Array.isArray(planRows)
                ? planRows.filter(r => (val(r,'SoftwareID') ?? '').toString() === id.toString())
                : [];
            addSection(box, 'Upgrade Plans', plans, plan => {
                const planId = val(plan,'UpgradePlanID');
                const label = labelFor('upgradeplan', plan);
                const status = val(plan,'Status');
                const window = formatDateRange(val(plan,'PlannedWindowStart'), val(plan,'PlannedWindowEnd'));
                const descParts = [status, window].filter(Boolean);
                return pillLink(`/details.html?type=upgradeplan&id=${encodeURIComponent(planId)}`, label, planId, descParts.join(' · '));
            }, {
                entity: 'UpgradePlan',
                label: 'UpgradePlan',
                params: { softwareId: id },
                softwareLabel: softwareContextLabel
            });
        }
    }

    /* -------------------- Boot -------------------- */
    (async () => {
        const params = new URLSearchParams(location.search);
        currentRawType = params.get('type');
        const idParam = params.get('id');

        if(!currentRawType || !idParam){
            detailBox.textContent = 'Missing parameters.';
            detailBox.removeAttribute('aria-busy');
            return;
        }

        currentTable = tableForType(currentRawType);
        currentId = idParam;

        await loadData();
    })();
</script>
</body>
</html>
